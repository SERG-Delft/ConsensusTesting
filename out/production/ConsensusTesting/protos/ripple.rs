// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ripple.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct TMManifest {
    // message fields
    stobject: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMManifest {
    fn default() -> &'a TMManifest {
        <TMManifest as ::protobuf::Message>::default_instance()
    }
}

impl TMManifest {
    pub fn new() -> TMManifest {
        ::std::default::Default::default()
    }

    // required bytes stobject = 1;


    pub fn get_stobject(&self) -> &[u8] {
        match self.stobject.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_stobject(&mut self) {
        self.stobject.clear();
    }

    pub fn has_stobject(&self) -> bool {
        self.stobject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stobject(&mut self, v: ::std::vec::Vec<u8>) {
        self.stobject = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stobject(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.stobject.is_none() {
            self.stobject.set_default();
        }
        self.stobject.as_mut().unwrap()
    }

    // Take field
    pub fn take_stobject(&mut self) -> ::std::vec::Vec<u8> {
        self.stobject.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMManifest {
    fn is_initialized(&self) -> bool {
        if self.stobject.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.stobject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stobject.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stobject.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMManifest {
        TMManifest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stobject",
                |m: &TMManifest| { &m.stobject },
                |m: &mut TMManifest| { &mut m.stobject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMManifest>(
                "TMManifest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMManifest {
        static instance: ::protobuf::rt::LazyV2<TMManifest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMManifest::new)
    }
}

impl ::protobuf::Clear for TMManifest {
    fn clear(&mut self) {
        self.stobject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMManifest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMManifests {
    // message fields
    pub list: ::protobuf::RepeatedField<TMManifest>,
    history: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMManifests {
    fn default() -> &'a TMManifests {
        <TMManifests as ::protobuf::Message>::default_instance()
    }
}

impl TMManifests {
    pub fn new() -> TMManifests {
        ::std::default::Default::default()
    }

    // repeated .protocol.TMManifest list = 1;


    pub fn get_list(&self) -> &[TMManifest] {
        &self.list
    }
    pub fn clear_list(&mut self) {
        self.list.clear();
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: ::protobuf::RepeatedField<TMManifest>) {
        self.list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_list(&mut self) -> &mut ::protobuf::RepeatedField<TMManifest> {
        &mut self.list
    }

    // Take field
    pub fn take_list(&mut self) -> ::protobuf::RepeatedField<TMManifest> {
        ::std::mem::replace(&mut self.list, ::protobuf::RepeatedField::new())
    }

    // optional bool history = 2;


    pub fn get_history(&self) -> bool {
        self.history.unwrap_or(false)
    }
    pub fn clear_history(&mut self) {
        self.history = ::std::option::Option::None;
    }

    pub fn has_history(&self) -> bool {
        self.history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history(&mut self, v: bool) {
        self.history = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMManifests {
    fn is_initialized(&self) -> bool {
        for v in &self.list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.history = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.history {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.history {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMManifests {
        TMManifests::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMManifest>>(
                "list",
                |m: &TMManifests| { &m.list },
                |m: &mut TMManifests| { &mut m.list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "history",
                |m: &TMManifests| { &m.history },
                |m: &mut TMManifests| { &mut m.history },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMManifests>(
                "TMManifests",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMManifests {
        static instance: ::protobuf::rt::LazyV2<TMManifests> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMManifests::new)
    }
}

impl ::protobuf::Clear for TMManifests {
    fn clear(&mut self) {
        self.list.clear();
        self.history = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMManifests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMManifests {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMClusterNode {
    // message fields
    publicKey: ::protobuf::SingularField<::std::string::String>,
    reportTime: ::std::option::Option<u32>,
    nodeLoad: ::std::option::Option<u32>,
    nodeName: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMClusterNode {
    fn default() -> &'a TMClusterNode {
        <TMClusterNode as ::protobuf::Message>::default_instance()
    }
}

impl TMClusterNode {
    pub fn new() -> TMClusterNode {
        ::std::default::Default::default()
    }

    // required string publicKey = 1;


    pub fn get_publicKey(&self) -> &str {
        match self.publicKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    pub fn has_publicKey(&self) -> bool {
        self.publicKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::std::string::String) {
        self.publicKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::std::string::String {
        if self.publicKey.is_none() {
            self.publicKey.set_default();
        }
        self.publicKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::std::string::String {
        self.publicKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 reportTime = 2;


    pub fn get_reportTime(&self) -> u32 {
        self.reportTime.unwrap_or(0)
    }
    pub fn clear_reportTime(&mut self) {
        self.reportTime = ::std::option::Option::None;
    }

    pub fn has_reportTime(&self) -> bool {
        self.reportTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportTime(&mut self, v: u32) {
        self.reportTime = ::std::option::Option::Some(v);
    }

    // required uint32 nodeLoad = 3;


    pub fn get_nodeLoad(&self) -> u32 {
        self.nodeLoad.unwrap_or(0)
    }
    pub fn clear_nodeLoad(&mut self) {
        self.nodeLoad = ::std::option::Option::None;
    }

    pub fn has_nodeLoad(&self) -> bool {
        self.nodeLoad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeLoad(&mut self, v: u32) {
        self.nodeLoad = ::std::option::Option::Some(v);
    }

    // optional string nodeName = 4;


    pub fn get_nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nodeName(&mut self) {
        self.nodeName.clear();
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName.set_default();
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 5;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TMClusterNode {
    fn is_initialized(&self) -> bool {
        if self.publicKey.is_none() {
            return false;
        }
        if self.reportTime.is_none() {
            return false;
        }
        if self.nodeLoad.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publicKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reportTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nodeLoad = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nodeName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.publicKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.reportTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nodeLoad {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.publicKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.reportTime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.nodeLoad {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMClusterNode {
        TMClusterNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "publicKey",
                |m: &TMClusterNode| { &m.publicKey },
                |m: &mut TMClusterNode| { &mut m.publicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reportTime",
                |m: &TMClusterNode| { &m.reportTime },
                |m: &mut TMClusterNode| { &mut m.reportTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nodeLoad",
                |m: &TMClusterNode| { &m.nodeLoad },
                |m: &mut TMClusterNode| { &mut m.nodeLoad },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nodeName",
                |m: &TMClusterNode| { &m.nodeName },
                |m: &mut TMClusterNode| { &mut m.nodeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &TMClusterNode| { &m.address },
                |m: &mut TMClusterNode| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMClusterNode>(
                "TMClusterNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMClusterNode {
        static instance: ::protobuf::rt::LazyV2<TMClusterNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMClusterNode::new)
    }
}

impl ::protobuf::Clear for TMClusterNode {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.reportTime = ::std::option::Option::None;
        self.nodeLoad = ::std::option::Option::None;
        self.nodeName.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMClusterNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMClusterNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMLoadSource {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    cost: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMLoadSource {
    fn default() -> &'a TMLoadSource {
        <TMLoadSource as ::protobuf::Message>::default_instance()
    }
}

impl TMLoadSource {
    pub fn new() -> TMLoadSource {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 cost = 2;


    pub fn get_cost(&self) -> u32 {
        self.cost.unwrap_or(0)
    }
    pub fn clear_cost(&mut self) {
        self.cost = ::std::option::Option::None;
    }

    pub fn has_cost(&self) -> bool {
        self.cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: u32) {
        self.cost = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMLoadSource {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.cost.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cost = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cost {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.cost {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMLoadSource {
        TMLoadSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TMLoadSource| { &m.name },
                |m: &mut TMLoadSource| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cost",
                |m: &TMLoadSource| { &m.cost },
                |m: &mut TMLoadSource| { &mut m.cost },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &TMLoadSource| { &m.count },
                |m: &mut TMLoadSource| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMLoadSource>(
                "TMLoadSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMLoadSource {
        static instance: ::protobuf::rt::LazyV2<TMLoadSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMLoadSource::new)
    }
}

impl ::protobuf::Clear for TMLoadSource {
    fn clear(&mut self) {
        self.name.clear();
        self.cost = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMLoadSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLoadSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMCluster {
    // message fields
    pub clusterNodes: ::protobuf::RepeatedField<TMClusterNode>,
    pub loadSources: ::protobuf::RepeatedField<TMLoadSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMCluster {
    fn default() -> &'a TMCluster {
        <TMCluster as ::protobuf::Message>::default_instance()
    }
}

impl TMCluster {
    pub fn new() -> TMCluster {
        ::std::default::Default::default()
    }

    // repeated .protocol.TMClusterNode clusterNodes = 1;


    pub fn get_clusterNodes(&self) -> &[TMClusterNode] {
        &self.clusterNodes
    }
    pub fn clear_clusterNodes(&mut self) {
        self.clusterNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusterNodes(&mut self, v: ::protobuf::RepeatedField<TMClusterNode>) {
        self.clusterNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusterNodes(&mut self) -> &mut ::protobuf::RepeatedField<TMClusterNode> {
        &mut self.clusterNodes
    }

    // Take field
    pub fn take_clusterNodes(&mut self) -> ::protobuf::RepeatedField<TMClusterNode> {
        ::std::mem::replace(&mut self.clusterNodes, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.TMLoadSource loadSources = 2;


    pub fn get_loadSources(&self) -> &[TMLoadSource] {
        &self.loadSources
    }
    pub fn clear_loadSources(&mut self) {
        self.loadSources.clear();
    }

    // Param is passed by value, moved
    pub fn set_loadSources(&mut self, v: ::protobuf::RepeatedField<TMLoadSource>) {
        self.loadSources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loadSources(&mut self) -> &mut ::protobuf::RepeatedField<TMLoadSource> {
        &mut self.loadSources
    }

    // Take field
    pub fn take_loadSources(&mut self) -> ::protobuf::RepeatedField<TMLoadSource> {
        ::std::mem::replace(&mut self.loadSources, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.clusterNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadSources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusterNodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.loadSources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusterNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.loadSources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusterNodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.loadSources {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMCluster {
        TMCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMClusterNode>>(
                "clusterNodes",
                |m: &TMCluster| { &m.clusterNodes },
                |m: &mut TMCluster| { &mut m.clusterNodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMLoadSource>>(
                "loadSources",
                |m: &TMCluster| { &m.loadSources },
                |m: &mut TMCluster| { &mut m.loadSources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMCluster>(
                "TMCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMCluster {
        static instance: ::protobuf::rt::LazyV2<TMCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMCluster::new)
    }
}

impl ::protobuf::Clear for TMCluster {
    fn clear(&mut self) {
        self.clusterNodes.clear();
        self.loadSources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMGetShardInfo {
    // message fields
    hops: ::std::option::Option<u32>,
    lastLink: ::std::option::Option<bool>,
    pub peerchain: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMGetShardInfo {
    fn default() -> &'a TMGetShardInfo {
        <TMGetShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TMGetShardInfo {
    pub fn new() -> TMGetShardInfo {
        ::std::default::Default::default()
    }

    // required uint32 hops = 1;


    pub fn get_hops(&self) -> u32 {
        self.hops.unwrap_or(0)
    }
    pub fn clear_hops(&mut self) {
        self.hops = ::std::option::Option::None;
    }

    pub fn has_hops(&self) -> bool {
        self.hops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: u32) {
        self.hops = ::std::option::Option::Some(v);
    }

    // optional bool lastLink = 2;


    pub fn get_lastLink(&self) -> bool {
        self.lastLink.unwrap_or(false)
    }
    pub fn clear_lastLink(&mut self) {
        self.lastLink = ::std::option::Option::None;
    }

    pub fn has_lastLink(&self) -> bool {
        self.lastLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastLink(&mut self, v: bool) {
        self.lastLink = ::std::option::Option::Some(v);
    }

    // repeated uint32 peerchain = 3;


    pub fn get_peerchain(&self) -> &[u32] {
        &self.peerchain
    }
    pub fn clear_peerchain(&mut self) {
        self.peerchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerchain(&mut self, v: ::std::vec::Vec<u32>) {
        self.peerchain = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerchain(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.peerchain
    }

    // Take field
    pub fn take_peerchain(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.peerchain, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMGetShardInfo {
    fn is_initialized(&self) -> bool {
        if self.hops.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hops = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastLink = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.peerchain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hops {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastLink {
            my_size += 2;
        }
        for value in &self.peerchain {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hops {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lastLink {
            os.write_bool(2, v)?;
        }
        for v in &self.peerchain {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMGetShardInfo {
        TMGetShardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hops",
                |m: &TMGetShardInfo| { &m.hops },
                |m: &mut TMGetShardInfo| { &mut m.hops },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lastLink",
                |m: &TMGetShardInfo| { &m.lastLink },
                |m: &mut TMGetShardInfo| { &mut m.lastLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "peerchain",
                |m: &TMGetShardInfo| { &m.peerchain },
                |m: &mut TMGetShardInfo| { &mut m.peerchain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMGetShardInfo>(
                "TMGetShardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMGetShardInfo {
        static instance: ::protobuf::rt::LazyV2<TMGetShardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMGetShardInfo::new)
    }
}

impl ::protobuf::Clear for TMGetShardInfo {
    fn clear(&mut self) {
        self.hops = ::std::option::Option::None;
        self.lastLink = ::std::option::Option::None;
        self.peerchain.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMGetShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMGetShardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMShardInfo {
    // message fields
    shardIndexes: ::protobuf::SingularField<::std::string::String>,
    nodePubKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    endpoint: ::protobuf::SingularField<::std::string::String>,
    lastLink: ::std::option::Option<bool>,
    pub peerchain: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMShardInfo {
    fn default() -> &'a TMShardInfo {
        <TMShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TMShardInfo {
    pub fn new() -> TMShardInfo {
        ::std::default::Default::default()
    }

    // required string shardIndexes = 1;


    pub fn get_shardIndexes(&self) -> &str {
        match self.shardIndexes.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shardIndexes(&mut self) {
        self.shardIndexes.clear();
    }

    pub fn has_shardIndexes(&self) -> bool {
        self.shardIndexes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shardIndexes(&mut self, v: ::std::string::String) {
        self.shardIndexes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shardIndexes(&mut self) -> &mut ::std::string::String {
        if self.shardIndexes.is_none() {
            self.shardIndexes.set_default();
        }
        self.shardIndexes.as_mut().unwrap()
    }

    // Take field
    pub fn take_shardIndexes(&mut self) -> ::std::string::String {
        self.shardIndexes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes nodePubKey = 2;


    pub fn get_nodePubKey(&self) -> &[u8] {
        match self.nodePubKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodePubKey(&mut self) {
        self.nodePubKey.clear();
    }

    pub fn has_nodePubKey(&self) -> bool {
        self.nodePubKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodePubKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodePubKey.is_none() {
            self.nodePubKey.set_default();
        }
        self.nodePubKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePubKey(&mut self) -> ::std::vec::Vec<u8> {
        self.nodePubKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string endpoint = 3;


    pub fn get_endpoint(&self) -> &str {
        match self.endpoint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        self.endpoint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool lastLink = 4;


    pub fn get_lastLink(&self) -> bool {
        self.lastLink.unwrap_or(false)
    }
    pub fn clear_lastLink(&mut self) {
        self.lastLink = ::std::option::Option::None;
    }

    pub fn has_lastLink(&self) -> bool {
        self.lastLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastLink(&mut self, v: bool) {
        self.lastLink = ::std::option::Option::Some(v);
    }

    // repeated uint32 peerchain = 5;


    pub fn get_peerchain(&self) -> &[u32] {
        &self.peerchain
    }
    pub fn clear_peerchain(&mut self) {
        self.peerchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerchain(&mut self, v: ::std::vec::Vec<u32>) {
        self.peerchain = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerchain(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.peerchain
    }

    // Take field
    pub fn take_peerchain(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.peerchain, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMShardInfo {
    fn is_initialized(&self) -> bool {
        if self.shardIndexes.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shardIndexes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodePubKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastLink = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.peerchain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shardIndexes.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lastLink {
            my_size += 2;
        }
        for value in &self.peerchain {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shardIndexes.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.lastLink {
            os.write_bool(4, v)?;
        }
        for v in &self.peerchain {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMShardInfo {
        TMShardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shardIndexes",
                |m: &TMShardInfo| { &m.shardIndexes },
                |m: &mut TMShardInfo| { &mut m.shardIndexes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodePubKey",
                |m: &TMShardInfo| { &m.nodePubKey },
                |m: &mut TMShardInfo| { &mut m.nodePubKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint",
                |m: &TMShardInfo| { &m.endpoint },
                |m: &mut TMShardInfo| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lastLink",
                |m: &TMShardInfo| { &m.lastLink },
                |m: &mut TMShardInfo| { &mut m.lastLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "peerchain",
                |m: &TMShardInfo| { &m.peerchain },
                |m: &mut TMShardInfo| { &mut m.peerchain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMShardInfo>(
                "TMShardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMShardInfo {
        static instance: ::protobuf::rt::LazyV2<TMShardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMShardInfo::new)
    }
}

impl ::protobuf::Clear for TMShardInfo {
    fn clear(&mut self) {
        self.shardIndexes.clear();
        self.nodePubKey.clear();
        self.endpoint.clear();
        self.lastLink = ::std::option::Option::None;
        self.peerchain.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMShardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMLink {
    // message fields
    nodePubKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMLink {
    fn default() -> &'a TMLink {
        <TMLink as ::protobuf::Message>::default_instance()
    }
}

impl TMLink {
    pub fn new() -> TMLink {
        ::std::default::Default::default()
    }

    // required bytes nodePubKey = 1;


    pub fn get_nodePubKey(&self) -> &[u8] {
        match self.nodePubKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodePubKey(&mut self) {
        self.nodePubKey.clear();
    }

    pub fn has_nodePubKey(&self) -> bool {
        self.nodePubKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodePubKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodePubKey.is_none() {
            self.nodePubKey.set_default();
        }
        self.nodePubKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePubKey(&mut self) -> ::std::vec::Vec<u8> {
        self.nodePubKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMLink {
    fn is_initialized(&self) -> bool {
        if self.nodePubKey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodePubKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nodePubKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nodePubKey.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMLink {
        TMLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodePubKey",
                |m: &TMLink| { &m.nodePubKey },
                |m: &mut TMLink| { &mut m.nodePubKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMLink>(
                "TMLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMLink {
        static instance: ::protobuf::rt::LazyV2<TMLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMLink::new)
    }
}

impl ::protobuf::Clear for TMLink {
    fn clear(&mut self) {
        self.nodePubKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMGetPeerShardInfo {
    // message fields
    hops: ::std::option::Option<u32>,
    lastLink: ::std::option::Option<bool>,
    pub peerChain: ::protobuf::RepeatedField<TMLink>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMGetPeerShardInfo {
    fn default() -> &'a TMGetPeerShardInfo {
        <TMGetPeerShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TMGetPeerShardInfo {
    pub fn new() -> TMGetPeerShardInfo {
        ::std::default::Default::default()
    }

    // required uint32 hops = 1;


    pub fn get_hops(&self) -> u32 {
        self.hops.unwrap_or(0)
    }
    pub fn clear_hops(&mut self) {
        self.hops = ::std::option::Option::None;
    }

    pub fn has_hops(&self) -> bool {
        self.hops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: u32) {
        self.hops = ::std::option::Option::Some(v);
    }

    // optional bool lastLink = 2;


    pub fn get_lastLink(&self) -> bool {
        self.lastLink.unwrap_or(false)
    }
    pub fn clear_lastLink(&mut self) {
        self.lastLink = ::std::option::Option::None;
    }

    pub fn has_lastLink(&self) -> bool {
        self.lastLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastLink(&mut self, v: bool) {
        self.lastLink = ::std::option::Option::Some(v);
    }

    // repeated .protocol.TMLink peerChain = 3;


    pub fn get_peerChain(&self) -> &[TMLink] {
        &self.peerChain
    }
    pub fn clear_peerChain(&mut self) {
        self.peerChain.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerChain(&mut self, v: ::protobuf::RepeatedField<TMLink>) {
        self.peerChain = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerChain(&mut self) -> &mut ::protobuf::RepeatedField<TMLink> {
        &mut self.peerChain
    }

    // Take field
    pub fn take_peerChain(&mut self) -> ::protobuf::RepeatedField<TMLink> {
        ::std::mem::replace(&mut self.peerChain, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMGetPeerShardInfo {
    fn is_initialized(&self) -> bool {
        if self.hops.is_none() {
            return false;
        }
        for v in &self.peerChain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hops = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastLink = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peerChain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hops {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastLink {
            my_size += 2;
        }
        for value in &self.peerChain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hops {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lastLink {
            os.write_bool(2, v)?;
        }
        for v in &self.peerChain {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMGetPeerShardInfo {
        TMGetPeerShardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hops",
                |m: &TMGetPeerShardInfo| { &m.hops },
                |m: &mut TMGetPeerShardInfo| { &mut m.hops },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lastLink",
                |m: &TMGetPeerShardInfo| { &m.lastLink },
                |m: &mut TMGetPeerShardInfo| { &mut m.lastLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMLink>>(
                "peerChain",
                |m: &TMGetPeerShardInfo| { &m.peerChain },
                |m: &mut TMGetPeerShardInfo| { &mut m.peerChain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMGetPeerShardInfo>(
                "TMGetPeerShardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMGetPeerShardInfo {
        static instance: ::protobuf::rt::LazyV2<TMGetPeerShardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMGetPeerShardInfo::new)
    }
}

impl ::protobuf::Clear for TMGetPeerShardInfo {
    fn clear(&mut self) {
        self.hops = ::std::option::Option::None;
        self.lastLink = ::std::option::Option::None;
        self.peerChain.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMGetPeerShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMGetPeerShardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMPeerShardInfo {
    // message fields
    shardIndexes: ::protobuf::SingularField<::std::string::String>,
    nodePubKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    endpoint: ::protobuf::SingularField<::std::string::String>,
    lastLink: ::std::option::Option<bool>,
    pub peerChain: ::protobuf::RepeatedField<TMLink>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMPeerShardInfo {
    fn default() -> &'a TMPeerShardInfo {
        <TMPeerShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl TMPeerShardInfo {
    pub fn new() -> TMPeerShardInfo {
        ::std::default::Default::default()
    }

    // required string shardIndexes = 1;


    pub fn get_shardIndexes(&self) -> &str {
        match self.shardIndexes.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shardIndexes(&mut self) {
        self.shardIndexes.clear();
    }

    pub fn has_shardIndexes(&self) -> bool {
        self.shardIndexes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shardIndexes(&mut self, v: ::std::string::String) {
        self.shardIndexes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shardIndexes(&mut self) -> &mut ::std::string::String {
        if self.shardIndexes.is_none() {
            self.shardIndexes.set_default();
        }
        self.shardIndexes.as_mut().unwrap()
    }

    // Take field
    pub fn take_shardIndexes(&mut self) -> ::std::string::String {
        self.shardIndexes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes nodePubKey = 2;


    pub fn get_nodePubKey(&self) -> &[u8] {
        match self.nodePubKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodePubKey(&mut self) {
        self.nodePubKey.clear();
    }

    pub fn has_nodePubKey(&self) -> bool {
        self.nodePubKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodePubKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodePubKey.is_none() {
            self.nodePubKey.set_default();
        }
        self.nodePubKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePubKey(&mut self) -> ::std::vec::Vec<u8> {
        self.nodePubKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string endpoint = 3;


    pub fn get_endpoint(&self) -> &str {
        match self.endpoint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        self.endpoint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool lastLink = 4;


    pub fn get_lastLink(&self) -> bool {
        self.lastLink.unwrap_or(false)
    }
    pub fn clear_lastLink(&mut self) {
        self.lastLink = ::std::option::Option::None;
    }

    pub fn has_lastLink(&self) -> bool {
        self.lastLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastLink(&mut self, v: bool) {
        self.lastLink = ::std::option::Option::Some(v);
    }

    // repeated .protocol.TMLink peerChain = 5;


    pub fn get_peerChain(&self) -> &[TMLink] {
        &self.peerChain
    }
    pub fn clear_peerChain(&mut self) {
        self.peerChain.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerChain(&mut self, v: ::protobuf::RepeatedField<TMLink>) {
        self.peerChain = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerChain(&mut self) -> &mut ::protobuf::RepeatedField<TMLink> {
        &mut self.peerChain
    }

    // Take field
    pub fn take_peerChain(&mut self) -> ::protobuf::RepeatedField<TMLink> {
        ::std::mem::replace(&mut self.peerChain, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMPeerShardInfo {
    fn is_initialized(&self) -> bool {
        if self.shardIndexes.is_none() {
            return false;
        }
        for v in &self.peerChain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shardIndexes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodePubKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastLink = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peerChain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shardIndexes.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lastLink {
            my_size += 2;
        }
        for value in &self.peerChain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shardIndexes.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.lastLink {
            os.write_bool(4, v)?;
        }
        for v in &self.peerChain {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMPeerShardInfo {
        TMPeerShardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shardIndexes",
                |m: &TMPeerShardInfo| { &m.shardIndexes },
                |m: &mut TMPeerShardInfo| { &mut m.shardIndexes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodePubKey",
                |m: &TMPeerShardInfo| { &m.nodePubKey },
                |m: &mut TMPeerShardInfo| { &mut m.nodePubKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint",
                |m: &TMPeerShardInfo| { &m.endpoint },
                |m: &mut TMPeerShardInfo| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lastLink",
                |m: &TMPeerShardInfo| { &m.lastLink },
                |m: &mut TMPeerShardInfo| { &mut m.lastLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMLink>>(
                "peerChain",
                |m: &TMPeerShardInfo| { &m.peerChain },
                |m: &mut TMPeerShardInfo| { &mut m.peerChain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMPeerShardInfo>(
                "TMPeerShardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMPeerShardInfo {
        static instance: ::protobuf::rt::LazyV2<TMPeerShardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMPeerShardInfo::new)
    }
}

impl ::protobuf::Clear for TMPeerShardInfo {
    fn clear(&mut self) {
        self.shardIndexes.clear();
        self.nodePubKey.clear();
        self.endpoint.clear();
        self.lastLink = ::std::option::Option::None;
        self.peerChain.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMPeerShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMPeerShardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMTransaction {
    // message fields
    rawTransaction: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    status: ::std::option::Option<TransactionStatus>,
    receiveTimestamp: ::std::option::Option<u64>,
    deferred: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMTransaction {
    fn default() -> &'a TMTransaction {
        <TMTransaction as ::protobuf::Message>::default_instance()
    }
}

impl TMTransaction {
    pub fn new() -> TMTransaction {
        ::std::default::Default::default()
    }

    // required bytes rawTransaction = 1;


    pub fn get_rawTransaction(&self) -> &[u8] {
        match self.rawTransaction.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rawTransaction(&mut self) {
        self.rawTransaction.clear();
    }

    pub fn has_rawTransaction(&self) -> bool {
        self.rawTransaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawTransaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.rawTransaction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawTransaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rawTransaction.is_none() {
            self.rawTransaction.set_default();
        }
        self.rawTransaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_rawTransaction(&mut self) -> ::std::vec::Vec<u8> {
        self.rawTransaction.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .protocol.TransactionStatus status = 2;


    pub fn get_status(&self) -> TransactionStatus {
        self.status.unwrap_or(TransactionStatus::tsNEW)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TransactionStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint64 receiveTimestamp = 3;


    pub fn get_receiveTimestamp(&self) -> u64 {
        self.receiveTimestamp.unwrap_or(0)
    }
    pub fn clear_receiveTimestamp(&mut self) {
        self.receiveTimestamp = ::std::option::Option::None;
    }

    pub fn has_receiveTimestamp(&self) -> bool {
        self.receiveTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiveTimestamp(&mut self, v: u64) {
        self.receiveTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool deferred = 4;


    pub fn get_deferred(&self) -> bool {
        self.deferred.unwrap_or(false)
    }
    pub fn clear_deferred(&mut self) {
        self.deferred = ::std::option::Option::None;
    }

    pub fn has_deferred(&self) -> bool {
        self.deferred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deferred(&mut self, v: bool) {
        self.deferred = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMTransaction {
    fn is_initialized(&self) -> bool {
        if self.rawTransaction.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rawTransaction)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiveTimestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deferred = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rawTransaction.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.receiveTimestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deferred {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rawTransaction.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.receiveTimestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.deferred {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMTransaction {
        TMTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rawTransaction",
                |m: &TMTransaction| { &m.rawTransaction },
                |m: &mut TMTransaction| { &mut m.rawTransaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionStatus>>(
                "status",
                |m: &TMTransaction| { &m.status },
                |m: &mut TMTransaction| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiveTimestamp",
                |m: &TMTransaction| { &m.receiveTimestamp },
                |m: &mut TMTransaction| { &mut m.receiveTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deferred",
                |m: &TMTransaction| { &m.deferred },
                |m: &mut TMTransaction| { &mut m.deferred },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMTransaction>(
                "TMTransaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMTransaction {
        static instance: ::protobuf::rt::LazyV2<TMTransaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMTransaction::new)
    }
}

impl ::protobuf::Clear for TMTransaction {
    fn clear(&mut self) {
        self.rawTransaction.clear();
        self.status = ::std::option::Option::None;
        self.receiveTimestamp = ::std::option::Option::None;
        self.deferred = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMStatusChange {
    // message fields
    newStatus: ::std::option::Option<NodeStatus>,
    newEvent: ::std::option::Option<NodeEvent>,
    ledgerSeq: ::std::option::Option<u32>,
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerHashPrevious: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    networkTime: ::std::option::Option<u64>,
    firstSeq: ::std::option::Option<u32>,
    lastSeq: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMStatusChange {
    fn default() -> &'a TMStatusChange {
        <TMStatusChange as ::protobuf::Message>::default_instance()
    }
}

impl TMStatusChange {
    pub fn new() -> TMStatusChange {
        ::std::default::Default::default()
    }

    // optional .protocol.NodeStatus newStatus = 1;


    pub fn get_newStatus(&self) -> NodeStatus {
        self.newStatus.unwrap_or(NodeStatus::nsCONNECTING)
    }
    pub fn clear_newStatus(&mut self) {
        self.newStatus = ::std::option::Option::None;
    }

    pub fn has_newStatus(&self) -> bool {
        self.newStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newStatus(&mut self, v: NodeStatus) {
        self.newStatus = ::std::option::Option::Some(v);
    }

    // optional .protocol.NodeEvent newEvent = 2;


    pub fn get_newEvent(&self) -> NodeEvent {
        self.newEvent.unwrap_or(NodeEvent::neCLOSING_LEDGER)
    }
    pub fn clear_newEvent(&mut self) {
        self.newEvent = ::std::option::Option::None;
    }

    pub fn has_newEvent(&self) -> bool {
        self.newEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newEvent(&mut self, v: NodeEvent) {
        self.newEvent = ::std::option::Option::Some(v);
    }

    // optional uint32 ledgerSeq = 3;


    pub fn get_ledgerSeq(&self) -> u32 {
        self.ledgerSeq.unwrap_or(0)
    }
    pub fn clear_ledgerSeq(&mut self) {
        self.ledgerSeq = ::std::option::Option::None;
    }

    pub fn has_ledgerSeq(&self) -> bool {
        self.ledgerSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerSeq(&mut self, v: u32) {
        self.ledgerSeq = ::std::option::Option::Some(v);
    }

    // optional bytes ledgerHash = 4;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ledgerHashPrevious = 5;


    pub fn get_ledgerHashPrevious(&self) -> &[u8] {
        match self.ledgerHashPrevious.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHashPrevious(&mut self) {
        self.ledgerHashPrevious.clear();
    }

    pub fn has_ledgerHashPrevious(&self) -> bool {
        self.ledgerHashPrevious.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHashPrevious(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHashPrevious = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHashPrevious(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHashPrevious.is_none() {
            self.ledgerHashPrevious.set_default();
        }
        self.ledgerHashPrevious.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHashPrevious(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHashPrevious.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 networkTime = 6;


    pub fn get_networkTime(&self) -> u64 {
        self.networkTime.unwrap_or(0)
    }
    pub fn clear_networkTime(&mut self) {
        self.networkTime = ::std::option::Option::None;
    }

    pub fn has_networkTime(&self) -> bool {
        self.networkTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networkTime(&mut self, v: u64) {
        self.networkTime = ::std::option::Option::Some(v);
    }

    // optional uint32 firstSeq = 7;


    pub fn get_firstSeq(&self) -> u32 {
        self.firstSeq.unwrap_or(0)
    }
    pub fn clear_firstSeq(&mut self) {
        self.firstSeq = ::std::option::Option::None;
    }

    pub fn has_firstSeq(&self) -> bool {
        self.firstSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstSeq(&mut self, v: u32) {
        self.firstSeq = ::std::option::Option::Some(v);
    }

    // optional uint32 lastSeq = 8;


    pub fn get_lastSeq(&self) -> u32 {
        self.lastSeq.unwrap_or(0)
    }
    pub fn clear_lastSeq(&mut self) {
        self.lastSeq = ::std::option::Option::None;
    }

    pub fn has_lastSeq(&self) -> bool {
        self.lastSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastSeq(&mut self, v: u32) {
        self.lastSeq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMStatusChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.newStatus, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.newEvent, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ledgerSeq = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHashPrevious)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.networkTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.firstSeq = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lastSeq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newStatus {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.newEvent {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.ledgerSeq {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.ledgerHashPrevious.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.networkTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.firstSeq {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastSeq {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newStatus {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.newEvent {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ledgerSeq {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.ledgerHashPrevious.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.networkTime {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.firstSeq {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lastSeq {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMStatusChange {
        TMStatusChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeStatus>>(
                "newStatus",
                |m: &TMStatusChange| { &m.newStatus },
                |m: &mut TMStatusChange| { &mut m.newStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeEvent>>(
                "newEvent",
                |m: &TMStatusChange| { &m.newEvent },
                |m: &mut TMStatusChange| { &mut m.newEvent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ledgerSeq",
                |m: &TMStatusChange| { &m.ledgerSeq },
                |m: &mut TMStatusChange| { &mut m.ledgerSeq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMStatusChange| { &m.ledgerHash },
                |m: &mut TMStatusChange| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHashPrevious",
                |m: &TMStatusChange| { &m.ledgerHashPrevious },
                |m: &mut TMStatusChange| { &mut m.ledgerHashPrevious },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "networkTime",
                |m: &TMStatusChange| { &m.networkTime },
                |m: &mut TMStatusChange| { &mut m.networkTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "firstSeq",
                |m: &TMStatusChange| { &m.firstSeq },
                |m: &mut TMStatusChange| { &mut m.firstSeq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lastSeq",
                |m: &TMStatusChange| { &m.lastSeq },
                |m: &mut TMStatusChange| { &mut m.lastSeq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMStatusChange>(
                "TMStatusChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMStatusChange {
        static instance: ::protobuf::rt::LazyV2<TMStatusChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMStatusChange::new)
    }
}

impl ::protobuf::Clear for TMStatusChange {
    fn clear(&mut self) {
        self.newStatus = ::std::option::Option::None;
        self.newEvent = ::std::option::Option::None;
        self.ledgerSeq = ::std::option::Option::None;
        self.ledgerHash.clear();
        self.ledgerHashPrevious.clear();
        self.networkTime = ::std::option::Option::None;
        self.firstSeq = ::std::option::Option::None;
        self.lastSeq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMStatusChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMStatusChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMProposeSet {
    // message fields
    proposeSeq: ::std::option::Option<u32>,
    currentTxHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nodePubKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    closeTime: ::std::option::Option<u32>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    previousledger: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub addedTransactions: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub removedTransactions: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    checkedSignature: ::std::option::Option<bool>,
    hops: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMProposeSet {
    fn default() -> &'a TMProposeSet {
        <TMProposeSet as ::protobuf::Message>::default_instance()
    }
}

impl TMProposeSet {
    pub fn new() -> TMProposeSet {
        ::std::default::Default::default()
    }

    // required uint32 proposeSeq = 1;


    pub fn get_proposeSeq(&self) -> u32 {
        self.proposeSeq.unwrap_or(0)
    }
    pub fn clear_proposeSeq(&mut self) {
        self.proposeSeq = ::std::option::Option::None;
    }

    pub fn has_proposeSeq(&self) -> bool {
        self.proposeSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposeSeq(&mut self, v: u32) {
        self.proposeSeq = ::std::option::Option::Some(v);
    }

    // required bytes currentTxHash = 2;


    pub fn get_currentTxHash(&self) -> &[u8] {
        match self.currentTxHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_currentTxHash(&mut self) {
        self.currentTxHash.clear();
    }

    pub fn has_currentTxHash(&self) -> bool {
        self.currentTxHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentTxHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.currentTxHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentTxHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.currentTxHash.is_none() {
            self.currentTxHash.set_default();
        }
        self.currentTxHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentTxHash(&mut self) -> ::std::vec::Vec<u8> {
        self.currentTxHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes nodePubKey = 3;


    pub fn get_nodePubKey(&self) -> &[u8] {
        match self.nodePubKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodePubKey(&mut self) {
        self.nodePubKey.clear();
    }

    pub fn has_nodePubKey(&self) -> bool {
        self.nodePubKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodePubKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodePubKey.is_none() {
            self.nodePubKey.set_default();
        }
        self.nodePubKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePubKey(&mut self) -> ::std::vec::Vec<u8> {
        self.nodePubKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 closeTime = 4;


    pub fn get_closeTime(&self) -> u32 {
        self.closeTime.unwrap_or(0)
    }
    pub fn clear_closeTime(&mut self) {
        self.closeTime = ::std::option::Option::None;
    }

    pub fn has_closeTime(&self) -> bool {
        self.closeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closeTime(&mut self, v: u32) {
        self.closeTime = ::std::option::Option::Some(v);
    }

    // required bytes signature = 5;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes previousledger = 6;


    pub fn get_previousledger(&self) -> &[u8] {
        match self.previousledger.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_previousledger(&mut self) {
        self.previousledger.clear();
    }

    pub fn has_previousledger(&self) -> bool {
        self.previousledger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previousledger(&mut self, v: ::std::vec::Vec<u8>) {
        self.previousledger = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previousledger(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.previousledger.is_none() {
            self.previousledger.set_default();
        }
        self.previousledger.as_mut().unwrap()
    }

    // Take field
    pub fn take_previousledger(&mut self) -> ::std::vec::Vec<u8> {
        self.previousledger.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes addedTransactions = 10;


    pub fn get_addedTransactions(&self) -> &[::std::vec::Vec<u8>] {
        &self.addedTransactions
    }
    pub fn clear_addedTransactions(&mut self) {
        self.addedTransactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_addedTransactions(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.addedTransactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addedTransactions(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.addedTransactions
    }

    // Take field
    pub fn take_addedTransactions(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.addedTransactions, ::protobuf::RepeatedField::new())
    }

    // repeated bytes removedTransactions = 11;


    pub fn get_removedTransactions(&self) -> &[::std::vec::Vec<u8>] {
        &self.removedTransactions
    }
    pub fn clear_removedTransactions(&mut self) {
        self.removedTransactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_removedTransactions(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.removedTransactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_removedTransactions(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.removedTransactions
    }

    // Take field
    pub fn take_removedTransactions(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.removedTransactions, ::protobuf::RepeatedField::new())
    }

    // optional bool checkedSignature = 7;


    pub fn get_checkedSignature(&self) -> bool {
        self.checkedSignature.unwrap_or(false)
    }
    pub fn clear_checkedSignature(&mut self) {
        self.checkedSignature = ::std::option::Option::None;
    }

    pub fn has_checkedSignature(&self) -> bool {
        self.checkedSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkedSignature(&mut self, v: bool) {
        self.checkedSignature = ::std::option::Option::Some(v);
    }

    // optional uint32 hops = 12;


    pub fn get_hops(&self) -> u32 {
        self.hops.unwrap_or(0)
    }
    pub fn clear_hops(&mut self) {
        self.hops = ::std::option::Option::None;
    }

    pub fn has_hops(&self) -> bool {
        self.hops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: u32) {
        self.hops = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMProposeSet {
    fn is_initialized(&self) -> bool {
        if self.proposeSeq.is_none() {
            return false;
        }
        if self.currentTxHash.is_none() {
            return false;
        }
        if self.nodePubKey.is_none() {
            return false;
        }
        if self.closeTime.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        if self.previousledger.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.proposeSeq = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.currentTxHash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodePubKey)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.closeTime = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.previousledger)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.addedTransactions)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.removedTransactions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkedSignature = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hops = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.proposeSeq {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currentTxHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.closeTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.previousledger.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        for value in &self.addedTransactions {
            my_size += ::protobuf::rt::bytes_size(10, &value);
        };
        for value in &self.removedTransactions {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        if let Some(v) = self.checkedSignature {
            my_size += 2;
        }
        if let Some(v) = self.hops {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.proposeSeq {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.currentTxHash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.nodePubKey.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.closeTime {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.previousledger.as_ref() {
            os.write_bytes(6, &v)?;
        }
        for v in &self.addedTransactions {
            os.write_bytes(10, &v)?;
        };
        for v in &self.removedTransactions {
            os.write_bytes(11, &v)?;
        };
        if let Some(v) = self.checkedSignature {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.hops {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMProposeSet {
        TMProposeSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "proposeSeq",
                |m: &TMProposeSet| { &m.proposeSeq },
                |m: &mut TMProposeSet| { &mut m.proposeSeq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "currentTxHash",
                |m: &TMProposeSet| { &m.currentTxHash },
                |m: &mut TMProposeSet| { &mut m.currentTxHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodePubKey",
                |m: &TMProposeSet| { &m.nodePubKey },
                |m: &mut TMProposeSet| { &mut m.nodePubKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "closeTime",
                |m: &TMProposeSet| { &m.closeTime },
                |m: &mut TMProposeSet| { &mut m.closeTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &TMProposeSet| { &m.signature },
                |m: &mut TMProposeSet| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "previousledger",
                |m: &TMProposeSet| { &m.previousledger },
                |m: &mut TMProposeSet| { &mut m.previousledger },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "addedTransactions",
                |m: &TMProposeSet| { &m.addedTransactions },
                |m: &mut TMProposeSet| { &mut m.addedTransactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "removedTransactions",
                |m: &TMProposeSet| { &m.removedTransactions },
                |m: &mut TMProposeSet| { &mut m.removedTransactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkedSignature",
                |m: &TMProposeSet| { &m.checkedSignature },
                |m: &mut TMProposeSet| { &mut m.checkedSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hops",
                |m: &TMProposeSet| { &m.hops },
                |m: &mut TMProposeSet| { &mut m.hops },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMProposeSet>(
                "TMProposeSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMProposeSet {
        static instance: ::protobuf::rt::LazyV2<TMProposeSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMProposeSet::new)
    }
}

impl ::protobuf::Clear for TMProposeSet {
    fn clear(&mut self) {
        self.proposeSeq = ::std::option::Option::None;
        self.currentTxHash.clear();
        self.nodePubKey.clear();
        self.closeTime = ::std::option::Option::None;
        self.signature.clear();
        self.previousledger.clear();
        self.addedTransactions.clear();
        self.removedTransactions.clear();
        self.checkedSignature = ::std::option::Option::None;
        self.hops = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMProposeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMProposeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMHaveTransactionSet {
    // message fields
    status: ::std::option::Option<TxSetStatus>,
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMHaveTransactionSet {
    fn default() -> &'a TMHaveTransactionSet {
        <TMHaveTransactionSet as ::protobuf::Message>::default_instance()
    }
}

impl TMHaveTransactionSet {
    pub fn new() -> TMHaveTransactionSet {
        ::std::default::Default::default()
    }

    // required .protocol.TxSetStatus status = 1;


    pub fn get_status(&self) -> TxSetStatus {
        self.status.unwrap_or(TxSetStatus::tsHAVE)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TxSetStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // required bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMHaveTransactionSet {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.hash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMHaveTransactionSet {
        TMHaveTransactionSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TxSetStatus>>(
                "status",
                |m: &TMHaveTransactionSet| { &m.status },
                |m: &mut TMHaveTransactionSet| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &TMHaveTransactionSet| { &m.hash },
                |m: &mut TMHaveTransactionSet| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMHaveTransactionSet>(
                "TMHaveTransactionSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMHaveTransactionSet {
        static instance: ::protobuf::rt::LazyV2<TMHaveTransactionSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMHaveTransactionSet::new)
    }
}

impl ::protobuf::Clear for TMHaveTransactionSet {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMHaveTransactionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMHaveTransactionSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMValidatorList {
    // message fields
    manifest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMValidatorList {
    fn default() -> &'a TMValidatorList {
        <TMValidatorList as ::protobuf::Message>::default_instance()
    }
}

impl TMValidatorList {
    pub fn new() -> TMValidatorList {
        ::std::default::Default::default()
    }

    // required bytes manifest = 1;


    pub fn get_manifest(&self) -> &[u8] {
        match self.manifest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_manifest(&mut self) {
        self.manifest.clear();
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.manifest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.manifest.is_none() {
            self.manifest.set_default();
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> ::std::vec::Vec<u8> {
        self.manifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes blob = 2;


    pub fn get_blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 version = 4;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMValidatorList {
    fn is_initialized(&self) -> bool {
        if self.manifest.is_none() {
            return false;
        }
        if self.blob.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.manifest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blob)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.manifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.manifest.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.blob.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMValidatorList {
        TMValidatorList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "manifest",
                |m: &TMValidatorList| { &m.manifest },
                |m: &mut TMValidatorList| { &mut m.manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blob",
                |m: &TMValidatorList| { &m.blob },
                |m: &mut TMValidatorList| { &mut m.blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &TMValidatorList| { &m.signature },
                |m: &mut TMValidatorList| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &TMValidatorList| { &m.version },
                |m: &mut TMValidatorList| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMValidatorList>(
                "TMValidatorList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMValidatorList {
        static instance: ::protobuf::rt::LazyV2<TMValidatorList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMValidatorList::new)
    }
}

impl ::protobuf::Clear for TMValidatorList {
    fn clear(&mut self) {
        self.manifest.clear();
        self.blob.clear();
        self.signature.clear();
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMValidatorList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMValidatorList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorBlobInfo {
    // message fields
    manifest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorBlobInfo {
    fn default() -> &'a ValidatorBlobInfo {
        <ValidatorBlobInfo as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorBlobInfo {
    pub fn new() -> ValidatorBlobInfo {
        ::std::default::Default::default()
    }

    // optional bytes manifest = 1;


    pub fn get_manifest(&self) -> &[u8] {
        match self.manifest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_manifest(&mut self) {
        self.manifest.clear();
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.manifest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.manifest.is_none() {
            self.manifest.set_default();
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> ::std::vec::Vec<u8> {
        self.manifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes blob = 2;


    pub fn get_blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ValidatorBlobInfo {
    fn is_initialized(&self) -> bool {
        if self.blob.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.manifest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blob)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.manifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.manifest.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.blob.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorBlobInfo {
        ValidatorBlobInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "manifest",
                |m: &ValidatorBlobInfo| { &m.manifest },
                |m: &mut ValidatorBlobInfo| { &mut m.manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blob",
                |m: &ValidatorBlobInfo| { &m.blob },
                |m: &mut ValidatorBlobInfo| { &mut m.blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &ValidatorBlobInfo| { &m.signature },
                |m: &mut ValidatorBlobInfo| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorBlobInfo>(
                "ValidatorBlobInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorBlobInfo {
        static instance: ::protobuf::rt::LazyV2<ValidatorBlobInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorBlobInfo::new)
    }
}

impl ::protobuf::Clear for ValidatorBlobInfo {
    fn clear(&mut self) {
        self.manifest.clear();
        self.blob.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorBlobInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorBlobInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMValidatorListCollection {
    // message fields
    version: ::std::option::Option<u32>,
    manifest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub blobs: ::protobuf::RepeatedField<ValidatorBlobInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMValidatorListCollection {
    fn default() -> &'a TMValidatorListCollection {
        <TMValidatorListCollection as ::protobuf::Message>::default_instance()
    }
}

impl TMValidatorListCollection {
    pub fn new() -> TMValidatorListCollection {
        ::std::default::Default::default()
    }

    // required uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required bytes manifest = 2;


    pub fn get_manifest(&self) -> &[u8] {
        match self.manifest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_manifest(&mut self) {
        self.manifest.clear();
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.manifest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.manifest.is_none() {
            self.manifest.set_default();
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> ::std::vec::Vec<u8> {
        self.manifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .protocol.ValidatorBlobInfo blobs = 3;


    pub fn get_blobs(&self) -> &[ValidatorBlobInfo] {
        &self.blobs
    }
    pub fn clear_blobs(&mut self) {
        self.blobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_blobs(&mut self, v: ::protobuf::RepeatedField<ValidatorBlobInfo>) {
        self.blobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blobs(&mut self) -> &mut ::protobuf::RepeatedField<ValidatorBlobInfo> {
        &mut self.blobs
    }

    // Take field
    pub fn take_blobs(&mut self) -> ::protobuf::RepeatedField<ValidatorBlobInfo> {
        ::std::mem::replace(&mut self.blobs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMValidatorListCollection {
    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        if self.manifest.is_none() {
            return false;
        }
        for v in &self.blobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.manifest)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.manifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.blobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.manifest.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.blobs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMValidatorListCollection {
        TMValidatorListCollection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &TMValidatorListCollection| { &m.version },
                |m: &mut TMValidatorListCollection| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "manifest",
                |m: &TMValidatorListCollection| { &m.manifest },
                |m: &mut TMValidatorListCollection| { &mut m.manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValidatorBlobInfo>>(
                "blobs",
                |m: &TMValidatorListCollection| { &m.blobs },
                |m: &mut TMValidatorListCollection| { &mut m.blobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMValidatorListCollection>(
                "TMValidatorListCollection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMValidatorListCollection {
        static instance: ::protobuf::rt::LazyV2<TMValidatorListCollection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMValidatorListCollection::new)
    }
}

impl ::protobuf::Clear for TMValidatorListCollection {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.manifest.clear();
        self.blobs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMValidatorListCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMValidatorListCollection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMValidation {
    // message fields
    validation: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    checkedSignature: ::std::option::Option<bool>,
    hops: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMValidation {
    fn default() -> &'a TMValidation {
        <TMValidation as ::protobuf::Message>::default_instance()
    }
}

impl TMValidation {
    pub fn new() -> TMValidation {
        ::std::default::Default::default()
    }

    // required bytes validation = 1;


    pub fn get_validation(&self) -> &[u8] {
        match self.validation.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_validation(&mut self) {
        self.validation.clear();
    }

    pub fn has_validation(&self) -> bool {
        self.validation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation(&mut self, v: ::std::vec::Vec<u8>) {
        self.validation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validation(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.validation.is_none() {
            self.validation.set_default();
        }
        self.validation.as_mut().unwrap()
    }

    // Take field
    pub fn take_validation(&mut self) -> ::std::vec::Vec<u8> {
        self.validation.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool checkedSignature = 2;


    pub fn get_checkedSignature(&self) -> bool {
        self.checkedSignature.unwrap_or(false)
    }
    pub fn clear_checkedSignature(&mut self) {
        self.checkedSignature = ::std::option::Option::None;
    }

    pub fn has_checkedSignature(&self) -> bool {
        self.checkedSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkedSignature(&mut self, v: bool) {
        self.checkedSignature = ::std::option::Option::Some(v);
    }

    // optional uint32 hops = 3;


    pub fn get_hops(&self) -> u32 {
        self.hops.unwrap_or(0)
    }
    pub fn clear_hops(&mut self) {
        self.hops = ::std::option::Option::None;
    }

    pub fn has_hops(&self) -> bool {
        self.hops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: u32) {
        self.hops = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMValidation {
    fn is_initialized(&self) -> bool {
        if self.validation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.validation)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkedSignature = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hops = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.validation.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.checkedSignature {
            my_size += 2;
        }
        if let Some(v) = self.hops {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.validation.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.checkedSignature {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.hops {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMValidation {
        TMValidation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "validation",
                |m: &TMValidation| { &m.validation },
                |m: &mut TMValidation| { &mut m.validation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkedSignature",
                |m: &TMValidation| { &m.checkedSignature },
                |m: &mut TMValidation| { &mut m.checkedSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hops",
                |m: &TMValidation| { &m.hops },
                |m: &mut TMValidation| { &mut m.hops },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMValidation>(
                "TMValidation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMValidation {
        static instance: ::protobuf::rt::LazyV2<TMValidation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMValidation::new)
    }
}

impl ::protobuf::Clear for TMValidation {
    fn clear(&mut self) {
        self.validation.clear();
        self.checkedSignature = ::std::option::Option::None;
        self.hops = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMValidation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMValidation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMEndpoints {
    // message fields
    version: ::std::option::Option<u32>,
    pub endpoints_v2: ::protobuf::RepeatedField<TMEndpoints_TMEndpointv2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMEndpoints {
    fn default() -> &'a TMEndpoints {
        <TMEndpoints as ::protobuf::Message>::default_instance()
    }
}

impl TMEndpoints {
    pub fn new() -> TMEndpoints {
        ::std::default::Default::default()
    }

    // required uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;


    pub fn get_endpoints_v2(&self) -> &[TMEndpoints_TMEndpointv2] {
        &self.endpoints_v2
    }
    pub fn clear_endpoints_v2(&mut self) {
        self.endpoints_v2.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints_v2(&mut self, v: ::protobuf::RepeatedField<TMEndpoints_TMEndpointv2>) {
        self.endpoints_v2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints_v2(&mut self) -> &mut ::protobuf::RepeatedField<TMEndpoints_TMEndpointv2> {
        &mut self.endpoints_v2
    }

    // Take field
    pub fn take_endpoints_v2(&mut self) -> ::protobuf::RepeatedField<TMEndpoints_TMEndpointv2> {
        ::std::mem::replace(&mut self.endpoints_v2, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMEndpoints {
    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        for v in &self.endpoints_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endpoints_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.endpoints_v2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.endpoints_v2 {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMEndpoints {
        TMEndpoints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &TMEndpoints| { &m.version },
                |m: &mut TMEndpoints| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMEndpoints_TMEndpointv2>>(
                "endpoints_v2",
                |m: &TMEndpoints| { &m.endpoints_v2 },
                |m: &mut TMEndpoints| { &mut m.endpoints_v2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMEndpoints>(
                "TMEndpoints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMEndpoints {
        static instance: ::protobuf::rt::LazyV2<TMEndpoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMEndpoints::new)
    }
}

impl ::protobuf::Clear for TMEndpoints {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.endpoints_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMEndpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMEndpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMEndpoints_TMEndpointv2 {
    // message fields
    endpoint: ::protobuf::SingularField<::std::string::String>,
    hops: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMEndpoints_TMEndpointv2 {
    fn default() -> &'a TMEndpoints_TMEndpointv2 {
        <TMEndpoints_TMEndpointv2 as ::protobuf::Message>::default_instance()
    }
}

impl TMEndpoints_TMEndpointv2 {
    pub fn new() -> TMEndpoints_TMEndpointv2 {
        ::std::default::Default::default()
    }

    // required string endpoint = 1;


    pub fn get_endpoint(&self) -> &str {
        match self.endpoint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        self.endpoint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 hops = 2;


    pub fn get_hops(&self) -> u32 {
        self.hops.unwrap_or(0)
    }
    pub fn clear_hops(&mut self) {
        self.hops = ::std::option::Option::None;
    }

    pub fn has_hops(&self) -> bool {
        self.hops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: u32) {
        self.hops = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMEndpoints_TMEndpointv2 {
    fn is_initialized(&self) -> bool {
        if self.endpoint.is_none() {
            return false;
        }
        if self.hops.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoint)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hops = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.endpoint.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hops {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.hops {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMEndpoints_TMEndpointv2 {
        TMEndpoints_TMEndpointv2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint",
                |m: &TMEndpoints_TMEndpointv2| { &m.endpoint },
                |m: &mut TMEndpoints_TMEndpointv2| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hops",
                |m: &TMEndpoints_TMEndpointv2| { &m.hops },
                |m: &mut TMEndpoints_TMEndpointv2| { &mut m.hops },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMEndpoints_TMEndpointv2>(
                "TMEndpoints.TMEndpointv2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMEndpoints_TMEndpointv2 {
        static instance: ::protobuf::rt::LazyV2<TMEndpoints_TMEndpointv2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMEndpoints_TMEndpointv2::new)
    }
}

impl ::protobuf::Clear for TMEndpoints_TMEndpointv2 {
    fn clear(&mut self) {
        self.endpoint.clear();
        self.hops = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMEndpoints_TMEndpointv2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMEndpoints_TMEndpointv2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMIndexedObject {
    // message fields
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nodeID: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    index: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerSeq: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMIndexedObject {
    fn default() -> &'a TMIndexedObject {
        <TMIndexedObject as ::protobuf::Message>::default_instance()
    }
}

impl TMIndexedObject {
    pub fn new() -> TMIndexedObject {
        ::std::default::Default::default()
    }

    // optional bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes nodeID = 2;


    pub fn get_nodeID(&self) -> &[u8] {
        match self.nodeID.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodeID(&mut self) {
        self.nodeID.clear();
    }

    pub fn has_nodeID(&self) -> bool {
        self.nodeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeID(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeID(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodeID.is_none() {
            self.nodeID.set_default();
        }
        self.nodeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeID(&mut self) -> ::std::vec::Vec<u8> {
        self.nodeID.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes index = 3;


    pub fn get_index(&self) -> &[u8] {
        match self.index.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        self.index.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ledgerSeq = 5;


    pub fn get_ledgerSeq(&self) -> u32 {
        self.ledgerSeq.unwrap_or(0)
    }
    pub fn clear_ledgerSeq(&mut self) {
        self.ledgerSeq = ::std::option::Option::None;
    }

    pub fn has_ledgerSeq(&self) -> bool {
        self.ledgerSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerSeq(&mut self, v: u32) {
        self.ledgerSeq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMIndexedObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodeID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.index)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ledgerSeq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.nodeID.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.index.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ledgerSeq {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.nodeID.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.ledgerSeq {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMIndexedObject {
        TMIndexedObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &TMIndexedObject| { &m.hash },
                |m: &mut TMIndexedObject| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodeID",
                |m: &TMIndexedObject| { &m.nodeID },
                |m: &mut TMIndexedObject| { &mut m.nodeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "index",
                |m: &TMIndexedObject| { &m.index },
                |m: &mut TMIndexedObject| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &TMIndexedObject| { &m.data },
                |m: &mut TMIndexedObject| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ledgerSeq",
                |m: &TMIndexedObject| { &m.ledgerSeq },
                |m: &mut TMIndexedObject| { &mut m.ledgerSeq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMIndexedObject>(
                "TMIndexedObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMIndexedObject {
        static instance: ::protobuf::rt::LazyV2<TMIndexedObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMIndexedObject::new)
    }
}

impl ::protobuf::Clear for TMIndexedObject {
    fn clear(&mut self) {
        self.hash.clear();
        self.nodeID.clear();
        self.index.clear();
        self.data.clear();
        self.ledgerSeq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMIndexedObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMIndexedObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMGetObjectByHash {
    // message fields
    field_type: ::std::option::Option<TMGetObjectByHash_ObjectType>,
    query: ::std::option::Option<bool>,
    seq: ::std::option::Option<u32>,
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fat: ::std::option::Option<bool>,
    pub objects: ::protobuf::RepeatedField<TMIndexedObject>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMGetObjectByHash {
    fn default() -> &'a TMGetObjectByHash {
        <TMGetObjectByHash as ::protobuf::Message>::default_instance()
    }
}

impl TMGetObjectByHash {
    pub fn new() -> TMGetObjectByHash {
        ::std::default::Default::default()
    }

    // required .protocol.TMGetObjectByHash.ObjectType type = 1;


    pub fn get_field_type(&self) -> TMGetObjectByHash_ObjectType {
        self.field_type.unwrap_or(TMGetObjectByHash_ObjectType::otUNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TMGetObjectByHash_ObjectType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required bool query = 2;


    pub fn get_query(&self) -> bool {
        self.query.unwrap_or(false)
    }
    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }

    // optional uint32 seq = 3;


    pub fn get_seq(&self) -> u32 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = ::std::option::Option::Some(v);
    }

    // optional bytes ledgerHash = 4;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool fat = 5;


    pub fn get_fat(&self) -> bool {
        self.fat.unwrap_or(false)
    }
    pub fn clear_fat(&mut self) {
        self.fat = ::std::option::Option::None;
    }

    pub fn has_fat(&self) -> bool {
        self.fat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fat(&mut self, v: bool) {
        self.fat = ::std::option::Option::Some(v);
    }

    // repeated .protocol.TMIndexedObject objects = 6;


    pub fn get_objects(&self) -> &[TMIndexedObject] {
        &self.objects
    }
    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<TMIndexedObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<TMIndexedObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<TMIndexedObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TMGetObjectByHash {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.query.is_none() {
            return false;
        }
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fat = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.query {
            my_size += 2;
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fat {
            my_size += 2;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.query {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.fat {
            os.write_bool(5, v)?;
        }
        for v in &self.objects {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMGetObjectByHash {
        TMGetObjectByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMGetObjectByHash_ObjectType>>(
                "type",
                |m: &TMGetObjectByHash| { &m.field_type },
                |m: &mut TMGetObjectByHash| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "query",
                |m: &TMGetObjectByHash| { &m.query },
                |m: &mut TMGetObjectByHash| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &TMGetObjectByHash| { &m.seq },
                |m: &mut TMGetObjectByHash| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMGetObjectByHash| { &m.ledgerHash },
                |m: &mut TMGetObjectByHash| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fat",
                |m: &TMGetObjectByHash| { &m.fat },
                |m: &mut TMGetObjectByHash| { &mut m.fat },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMIndexedObject>>(
                "objects",
                |m: &TMGetObjectByHash| { &m.objects },
                |m: &mut TMGetObjectByHash| { &mut m.objects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMGetObjectByHash>(
                "TMGetObjectByHash",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMGetObjectByHash {
        static instance: ::protobuf::rt::LazyV2<TMGetObjectByHash> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMGetObjectByHash::new)
    }
}

impl ::protobuf::Clear for TMGetObjectByHash {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.ledgerHash.clear();
        self.fat = ::std::option::Option::None;
        self.objects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMGetObjectByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMGetObjectByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMGetObjectByHash_ObjectType {
    otUNKNOWN = 0,
    otLEDGER = 1,
    otTRANSACTION = 2,
    otTRANSACTION_NODE = 3,
    otSTATE_NODE = 4,
    otCAS_OBJECT = 5,
    otFETCH_PACK = 6,
}

impl ::protobuf::ProtobufEnum for TMGetObjectByHash_ObjectType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMGetObjectByHash_ObjectType> {
        match value {
            0 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otUNKNOWN),
            1 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otLEDGER),
            2 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otTRANSACTION),
            3 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otTRANSACTION_NODE),
            4 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otSTATE_NODE),
            5 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otCAS_OBJECT),
            6 => ::std::option::Option::Some(TMGetObjectByHash_ObjectType::otFETCH_PACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMGetObjectByHash_ObjectType] = &[
            TMGetObjectByHash_ObjectType::otUNKNOWN,
            TMGetObjectByHash_ObjectType::otLEDGER,
            TMGetObjectByHash_ObjectType::otTRANSACTION,
            TMGetObjectByHash_ObjectType::otTRANSACTION_NODE,
            TMGetObjectByHash_ObjectType::otSTATE_NODE,
            TMGetObjectByHash_ObjectType::otCAS_OBJECT,
            TMGetObjectByHash_ObjectType::otFETCH_PACK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMGetObjectByHash_ObjectType>("TMGetObjectByHash.ObjectType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMGetObjectByHash_ObjectType {
}

impl ::std::default::Default for TMGetObjectByHash_ObjectType {
    fn default() -> Self {
        TMGetObjectByHash_ObjectType::otUNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for TMGetObjectByHash_ObjectType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMLedgerNode {
    // message fields
    nodedata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nodeid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMLedgerNode {
    fn default() -> &'a TMLedgerNode {
        <TMLedgerNode as ::protobuf::Message>::default_instance()
    }
}

impl TMLedgerNode {
    pub fn new() -> TMLedgerNode {
        ::std::default::Default::default()
    }

    // required bytes nodedata = 1;


    pub fn get_nodedata(&self) -> &[u8] {
        match self.nodedata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodedata(&mut self) {
        self.nodedata.clear();
    }

    pub fn has_nodedata(&self) -> bool {
        self.nodedata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodedata(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodedata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodedata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodedata.is_none() {
            self.nodedata.set_default();
        }
        self.nodedata.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodedata(&mut self) -> ::std::vec::Vec<u8> {
        self.nodedata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes nodeid = 2;


    pub fn get_nodeid(&self) -> &[u8] {
        match self.nodeid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nodeid(&mut self) {
        self.nodeid.clear();
    }

    pub fn has_nodeid(&self) -> bool {
        self.nodeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeid(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodeid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nodeid.is_none() {
            self.nodeid.set_default();
        }
        self.nodeid.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeid(&mut self) -> ::std::vec::Vec<u8> {
        self.nodeid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMLedgerNode {
    fn is_initialized(&self) -> bool {
        if self.nodedata.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodedata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nodeid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nodedata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.nodeid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nodedata.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.nodeid.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMLedgerNode {
        TMLedgerNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodedata",
                |m: &TMLedgerNode| { &m.nodedata },
                |m: &mut TMLedgerNode| { &mut m.nodedata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodeid",
                |m: &TMLedgerNode| { &m.nodeid },
                |m: &mut TMLedgerNode| { &mut m.nodeid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMLedgerNode>(
                "TMLedgerNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMLedgerNode {
        static instance: ::protobuf::rt::LazyV2<TMLedgerNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMLedgerNode::new)
    }
}

impl ::protobuf::Clear for TMLedgerNode {
    fn clear(&mut self) {
        self.nodedata.clear();
        self.nodeid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMLedgerNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLedgerNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMGetLedger {
    // message fields
    itype: ::std::option::Option<TMLedgerInfoType>,
    ltype: ::std::option::Option<TMLedgerType>,
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerSeq: ::std::option::Option<u32>,
    pub nodeIDs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    requestCookie: ::std::option::Option<u64>,
    queryType: ::std::option::Option<TMQueryType>,
    queryDepth: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMGetLedger {
    fn default() -> &'a TMGetLedger {
        <TMGetLedger as ::protobuf::Message>::default_instance()
    }
}

impl TMGetLedger {
    pub fn new() -> TMGetLedger {
        ::std::default::Default::default()
    }

    // required .protocol.TMLedgerInfoType itype = 1;


    pub fn get_itype(&self) -> TMLedgerInfoType {
        self.itype.unwrap_or(TMLedgerInfoType::liBASE)
    }
    pub fn clear_itype(&mut self) {
        self.itype = ::std::option::Option::None;
    }

    pub fn has_itype(&self) -> bool {
        self.itype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itype(&mut self, v: TMLedgerInfoType) {
        self.itype = ::std::option::Option::Some(v);
    }

    // optional .protocol.TMLedgerType ltype = 2;


    pub fn get_ltype(&self) -> TMLedgerType {
        self.ltype.unwrap_or(TMLedgerType::ltACCEPTED)
    }
    pub fn clear_ltype(&mut self) {
        self.ltype = ::std::option::Option::None;
    }

    pub fn has_ltype(&self) -> bool {
        self.ltype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ltype(&mut self, v: TMLedgerType) {
        self.ltype = ::std::option::Option::Some(v);
    }

    // optional bytes ledgerHash = 3;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ledgerSeq = 4;


    pub fn get_ledgerSeq(&self) -> u32 {
        self.ledgerSeq.unwrap_or(0)
    }
    pub fn clear_ledgerSeq(&mut self) {
        self.ledgerSeq = ::std::option::Option::None;
    }

    pub fn has_ledgerSeq(&self) -> bool {
        self.ledgerSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerSeq(&mut self, v: u32) {
        self.ledgerSeq = ::std::option::Option::Some(v);
    }

    // repeated bytes nodeIDs = 5;


    pub fn get_nodeIDs(&self) -> &[::std::vec::Vec<u8>] {
        &self.nodeIDs
    }
    pub fn clear_nodeIDs(&mut self) {
        self.nodeIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeIDs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.nodeIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.nodeIDs
    }

    // Take field
    pub fn take_nodeIDs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.nodeIDs, ::protobuf::RepeatedField::new())
    }

    // optional uint64 requestCookie = 6;


    pub fn get_requestCookie(&self) -> u64 {
        self.requestCookie.unwrap_or(0)
    }
    pub fn clear_requestCookie(&mut self) {
        self.requestCookie = ::std::option::Option::None;
    }

    pub fn has_requestCookie(&self) -> bool {
        self.requestCookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestCookie(&mut self, v: u64) {
        self.requestCookie = ::std::option::Option::Some(v);
    }

    // optional .protocol.TMQueryType queryType = 7;


    pub fn get_queryType(&self) -> TMQueryType {
        self.queryType.unwrap_or(TMQueryType::qtINDIRECT)
    }
    pub fn clear_queryType(&mut self) {
        self.queryType = ::std::option::Option::None;
    }

    pub fn has_queryType(&self) -> bool {
        self.queryType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryType(&mut self, v: TMQueryType) {
        self.queryType = ::std::option::Option::Some(v);
    }

    // optional uint32 queryDepth = 8;


    pub fn get_queryDepth(&self) -> u32 {
        self.queryDepth.unwrap_or(0)
    }
    pub fn clear_queryDepth(&mut self) {
        self.queryDepth = ::std::option::Option::None;
    }

    pub fn has_queryDepth(&self) -> bool {
        self.queryDepth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryDepth(&mut self, v: u32) {
        self.queryDepth = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMGetLedger {
    fn is_initialized(&self) -> bool {
        if self.itype.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.itype, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ltype, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ledgerSeq = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.nodeIDs)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.requestCookie = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.queryType, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.queryDepth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itype {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.ltype {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.ledgerSeq {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.nodeIDs {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if let Some(v) = self.requestCookie {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queryType {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.queryDepth {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itype {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ltype {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.ledgerSeq {
            os.write_uint32(4, v)?;
        }
        for v in &self.nodeIDs {
            os.write_bytes(5, &v)?;
        };
        if let Some(v) = self.requestCookie {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.queryType {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.queryDepth {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMGetLedger {
        TMGetLedger::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMLedgerInfoType>>(
                "itype",
                |m: &TMGetLedger| { &m.itype },
                |m: &mut TMGetLedger| { &mut m.itype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMLedgerType>>(
                "ltype",
                |m: &TMGetLedger| { &m.ltype },
                |m: &mut TMGetLedger| { &mut m.ltype },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMGetLedger| { &m.ledgerHash },
                |m: &mut TMGetLedger| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ledgerSeq",
                |m: &TMGetLedger| { &m.ledgerSeq },
                |m: &mut TMGetLedger| { &mut m.ledgerSeq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nodeIDs",
                |m: &TMGetLedger| { &m.nodeIDs },
                |m: &mut TMGetLedger| { &mut m.nodeIDs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "requestCookie",
                |m: &TMGetLedger| { &m.requestCookie },
                |m: &mut TMGetLedger| { &mut m.requestCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMQueryType>>(
                "queryType",
                |m: &TMGetLedger| { &m.queryType },
                |m: &mut TMGetLedger| { &mut m.queryType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "queryDepth",
                |m: &TMGetLedger| { &m.queryDepth },
                |m: &mut TMGetLedger| { &mut m.queryDepth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMGetLedger>(
                "TMGetLedger",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMGetLedger {
        static instance: ::protobuf::rt::LazyV2<TMGetLedger> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMGetLedger::new)
    }
}

impl ::protobuf::Clear for TMGetLedger {
    fn clear(&mut self) {
        self.itype = ::std::option::Option::None;
        self.ltype = ::std::option::Option::None;
        self.ledgerHash.clear();
        self.ledgerSeq = ::std::option::Option::None;
        self.nodeIDs.clear();
        self.requestCookie = ::std::option::Option::None;
        self.queryType = ::std::option::Option::None;
        self.queryDepth = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMGetLedger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMGetLedger {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMLedgerData {
    // message fields
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerSeq: ::std::option::Option<u32>,
    field_type: ::std::option::Option<TMLedgerInfoType>,
    pub nodes: ::protobuf::RepeatedField<TMLedgerNode>,
    requestCookie: ::std::option::Option<u32>,
    error: ::std::option::Option<TMReplyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMLedgerData {
    fn default() -> &'a TMLedgerData {
        <TMLedgerData as ::protobuf::Message>::default_instance()
    }
}

impl TMLedgerData {
    pub fn new() -> TMLedgerData {
        ::std::default::Default::default()
    }

    // required bytes ledgerHash = 1;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 ledgerSeq = 2;


    pub fn get_ledgerSeq(&self) -> u32 {
        self.ledgerSeq.unwrap_or(0)
    }
    pub fn clear_ledgerSeq(&mut self) {
        self.ledgerSeq = ::std::option::Option::None;
    }

    pub fn has_ledgerSeq(&self) -> bool {
        self.ledgerSeq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerSeq(&mut self, v: u32) {
        self.ledgerSeq = ::std::option::Option::Some(v);
    }

    // required .protocol.TMLedgerInfoType type = 3;


    pub fn get_field_type(&self) -> TMLedgerInfoType {
        self.field_type.unwrap_or(TMLedgerInfoType::liBASE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TMLedgerInfoType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated .protocol.TMLedgerNode nodes = 4;


    pub fn get_nodes(&self) -> &[TMLedgerNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<TMLedgerNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<TMLedgerNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<TMLedgerNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // optional uint32 requestCookie = 5;


    pub fn get_requestCookie(&self) -> u32 {
        self.requestCookie.unwrap_or(0)
    }
    pub fn clear_requestCookie(&mut self) {
        self.requestCookie = ::std::option::Option::None;
    }

    pub fn has_requestCookie(&self) -> bool {
        self.requestCookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestCookie(&mut self, v: u32) {
        self.requestCookie = ::std::option::Option::Some(v);
    }

    // optional .protocol.TMReplyError error = 6;


    pub fn get_error(&self) -> TMReplyError {
        self.error.unwrap_or(TMReplyError::reNO_LEDGER)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: TMReplyError) {
        self.error = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMLedgerData {
    fn is_initialized(&self) -> bool {
        if self.ledgerHash.is_none() {
            return false;
        }
        if self.ledgerSeq.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ledgerSeq = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requestCookie = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.ledgerSeq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.requestCookie {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.ledgerSeq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.nodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.requestCookie {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMLedgerData {
        TMLedgerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMLedgerData| { &m.ledgerHash },
                |m: &mut TMLedgerData| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ledgerSeq",
                |m: &TMLedgerData| { &m.ledgerSeq },
                |m: &mut TMLedgerData| { &mut m.ledgerSeq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMLedgerInfoType>>(
                "type",
                |m: &TMLedgerData| { &m.field_type },
                |m: &mut TMLedgerData| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMLedgerNode>>(
                "nodes",
                |m: &TMLedgerData| { &m.nodes },
                |m: &mut TMLedgerData| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "requestCookie",
                |m: &TMLedgerData| { &m.requestCookie },
                |m: &mut TMLedgerData| { &mut m.requestCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMReplyError>>(
                "error",
                |m: &TMLedgerData| { &m.error },
                |m: &mut TMLedgerData| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMLedgerData>(
                "TMLedgerData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMLedgerData {
        static instance: ::protobuf::rt::LazyV2<TMLedgerData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMLedgerData::new)
    }
}

impl ::protobuf::Clear for TMLedgerData {
    fn clear(&mut self) {
        self.ledgerHash.clear();
        self.ledgerSeq = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.nodes.clear();
        self.requestCookie = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMLedgerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLedgerData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMPing {
    // message fields
    field_type: ::std::option::Option<TMPing_pingType>,
    seq: ::std::option::Option<u32>,
    pingTime: ::std::option::Option<u64>,
    netTime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMPing {
    fn default() -> &'a TMPing {
        <TMPing as ::protobuf::Message>::default_instance()
    }
}

impl TMPing {
    pub fn new() -> TMPing {
        ::std::default::Default::default()
    }

    // required .protocol.TMPing.pingType type = 1;


    pub fn get_field_type(&self) -> TMPing_pingType {
        self.field_type.unwrap_or(TMPing_pingType::ptPING)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TMPing_pingType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 seq = 2;


    pub fn get_seq(&self) -> u32 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = ::std::option::Option::Some(v);
    }

    // optional uint64 pingTime = 3;


    pub fn get_pingTime(&self) -> u64 {
        self.pingTime.unwrap_or(0)
    }
    pub fn clear_pingTime(&mut self) {
        self.pingTime = ::std::option::Option::None;
    }

    pub fn has_pingTime(&self) -> bool {
        self.pingTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pingTime(&mut self, v: u64) {
        self.pingTime = ::std::option::Option::Some(v);
    }

    // optional uint64 netTime = 4;


    pub fn get_netTime(&self) -> u64 {
        self.netTime.unwrap_or(0)
    }
    pub fn clear_netTime(&mut self) {
        self.netTime = ::std::option::Option::None;
    }

    pub fn has_netTime(&self) -> bool {
        self.netTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_netTime(&mut self, v: u64) {
        self.netTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMPing {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pingTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.netTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pingTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.netTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.pingTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.netTime {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMPing {
        TMPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMPing_pingType>>(
                "type",
                |m: &TMPing| { &m.field_type },
                |m: &mut TMPing| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &TMPing| { &m.seq },
                |m: &mut TMPing| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pingTime",
                |m: &TMPing| { &m.pingTime },
                |m: &mut TMPing| { &mut m.pingTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "netTime",
                |m: &TMPing| { &m.netTime },
                |m: &mut TMPing| { &mut m.netTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMPing>(
                "TMPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMPing {
        static instance: ::protobuf::rt::LazyV2<TMPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMPing::new)
    }
}

impl ::protobuf::Clear for TMPing {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.pingTime = ::std::option::Option::None;
        self.netTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMPing_pingType {
    ptPING = 0,
    ptPONG = 1,
}

impl ::protobuf::ProtobufEnum for TMPing_pingType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMPing_pingType> {
        match value {
            0 => ::std::option::Option::Some(TMPing_pingType::ptPING),
            1 => ::std::option::Option::Some(TMPing_pingType::ptPONG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMPing_pingType] = &[
            TMPing_pingType::ptPING,
            TMPing_pingType::ptPONG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMPing_pingType>("TMPing.pingType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMPing_pingType {
}

impl ::std::default::Default for TMPing_pingType {
    fn default() -> Self {
        TMPing_pingType::ptPING
    }
}

impl ::protobuf::reflect::ProtobufValue for TMPing_pingType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMSquelch {
    // message fields
    squelch: ::std::option::Option<bool>,
    validatorPubKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    squelchDuration: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMSquelch {
    fn default() -> &'a TMSquelch {
        <TMSquelch as ::protobuf::Message>::default_instance()
    }
}

impl TMSquelch {
    pub fn new() -> TMSquelch {
        ::std::default::Default::default()
    }

    // required bool squelch = 1;


    pub fn get_squelch(&self) -> bool {
        self.squelch.unwrap_or(false)
    }
    pub fn clear_squelch(&mut self) {
        self.squelch = ::std::option::Option::None;
    }

    pub fn has_squelch(&self) -> bool {
        self.squelch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squelch(&mut self, v: bool) {
        self.squelch = ::std::option::Option::Some(v);
    }

    // required bytes validatorPubKey = 2;


    pub fn get_validatorPubKey(&self) -> &[u8] {
        match self.validatorPubKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_validatorPubKey(&mut self) {
        self.validatorPubKey.clear();
    }

    pub fn has_validatorPubKey(&self) -> bool {
        self.validatorPubKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validatorPubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.validatorPubKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validatorPubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.validatorPubKey.is_none() {
            self.validatorPubKey.set_default();
        }
        self.validatorPubKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_validatorPubKey(&mut self) -> ::std::vec::Vec<u8> {
        self.validatorPubKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 squelchDuration = 3;


    pub fn get_squelchDuration(&self) -> u32 {
        self.squelchDuration.unwrap_or(0)
    }
    pub fn clear_squelchDuration(&mut self) {
        self.squelchDuration = ::std::option::Option::None;
    }

    pub fn has_squelchDuration(&self) -> bool {
        self.squelchDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squelchDuration(&mut self, v: u32) {
        self.squelchDuration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMSquelch {
    fn is_initialized(&self) -> bool {
        if self.squelch.is_none() {
            return false;
        }
        if self.validatorPubKey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.squelch = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.validatorPubKey)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.squelchDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.squelch {
            my_size += 2;
        }
        if let Some(ref v) = self.validatorPubKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.squelchDuration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.squelch {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.validatorPubKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.squelchDuration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMSquelch {
        TMSquelch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "squelch",
                |m: &TMSquelch| { &m.squelch },
                |m: &mut TMSquelch| { &mut m.squelch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "validatorPubKey",
                |m: &TMSquelch| { &m.validatorPubKey },
                |m: &mut TMSquelch| { &mut m.validatorPubKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "squelchDuration",
                |m: &TMSquelch| { &m.squelchDuration },
                |m: &mut TMSquelch| { &mut m.squelchDuration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMSquelch>(
                "TMSquelch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMSquelch {
        static instance: ::protobuf::rt::LazyV2<TMSquelch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMSquelch::new)
    }
}

impl ::protobuf::Clear for TMSquelch {
    fn clear(&mut self) {
        self.squelch = ::std::option::Option::None;
        self.validatorPubKey.clear();
        self.squelchDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMSquelch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMSquelch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMProofPathRequest {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<TMLedgerMapType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMProofPathRequest {
    fn default() -> &'a TMProofPathRequest {
        <TMProofPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl TMProofPathRequest {
    pub fn new() -> TMProofPathRequest {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes ledgerHash = 2;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .protocol.TMLedgerMapType type = 3;


    pub fn get_field_type(&self) -> TMLedgerMapType {
        self.field_type.unwrap_or(TMLedgerMapType::lmTRANASCTION)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TMLedgerMapType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMProofPathRequest {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.ledgerHash.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMProofPathRequest {
        TMProofPathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &TMProofPathRequest| { &m.key },
                |m: &mut TMProofPathRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMProofPathRequest| { &m.ledgerHash },
                |m: &mut TMProofPathRequest| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMLedgerMapType>>(
                "type",
                |m: &TMProofPathRequest| { &m.field_type },
                |m: &mut TMProofPathRequest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMProofPathRequest>(
                "TMProofPathRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMProofPathRequest {
        static instance: ::protobuf::rt::LazyV2<TMProofPathRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMProofPathRequest::new)
    }
}

impl ::protobuf::Clear for TMProofPathRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.ledgerHash.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMProofPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMProofPathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMProofPathResponse {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<TMLedgerMapType>,
    ledgerHeader: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub path: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    error: ::std::option::Option<TMReplyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMProofPathResponse {
    fn default() -> &'a TMProofPathResponse {
        <TMProofPathResponse as ::protobuf::Message>::default_instance()
    }
}

impl TMProofPathResponse {
    pub fn new() -> TMProofPathResponse {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes ledgerHash = 2;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .protocol.TMLedgerMapType type = 3;


    pub fn get_field_type(&self) -> TMLedgerMapType {
        self.field_type.unwrap_or(TMLedgerMapType::lmTRANASCTION)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TMLedgerMapType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes ledgerHeader = 4;


    pub fn get_ledgerHeader(&self) -> &[u8] {
        match self.ledgerHeader.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHeader(&mut self) {
        self.ledgerHeader.clear();
    }

    pub fn has_ledgerHeader(&self) -> bool {
        self.ledgerHeader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHeader(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHeader = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHeader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHeader.is_none() {
            self.ledgerHeader.set_default();
        }
        self.ledgerHeader.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHeader(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHeader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes path = 5;


    pub fn get_path(&self) -> &[::std::vec::Vec<u8>] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    // optional .protocol.TMReplyError error = 6;


    pub fn get_error(&self) -> TMReplyError {
        self.error.unwrap_or(TMReplyError::reNO_LEDGER)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: TMReplyError) {
        self.error = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMProofPathResponse {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.ledgerHash.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHeader)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.path)?;
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.ledgerHeader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.ledgerHeader.as_ref() {
            os.write_bytes(4, &v)?;
        }
        for v in &self.path {
            os.write_bytes(5, &v)?;
        };
        if let Some(v) = self.error {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMProofPathResponse {
        TMProofPathResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &TMProofPathResponse| { &m.key },
                |m: &mut TMProofPathResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMProofPathResponse| { &m.ledgerHash },
                |m: &mut TMProofPathResponse| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMLedgerMapType>>(
                "type",
                |m: &TMProofPathResponse| { &m.field_type },
                |m: &mut TMProofPathResponse| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHeader",
                |m: &TMProofPathResponse| { &m.ledgerHeader },
                |m: &mut TMProofPathResponse| { &mut m.ledgerHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "path",
                |m: &TMProofPathResponse| { &m.path },
                |m: &mut TMProofPathResponse| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMReplyError>>(
                "error",
                |m: &TMProofPathResponse| { &m.error },
                |m: &mut TMProofPathResponse| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMProofPathResponse>(
                "TMProofPathResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMProofPathResponse {
        static instance: ::protobuf::rt::LazyV2<TMProofPathResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMProofPathResponse::new)
    }
}

impl ::protobuf::Clear for TMProofPathResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.ledgerHash.clear();
        self.field_type = ::std::option::Option::None;
        self.ledgerHeader.clear();
        self.path.clear();
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMProofPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMProofPathResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMReplayDeltaRequest {
    // message fields
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMReplayDeltaRequest {
    fn default() -> &'a TMReplayDeltaRequest {
        <TMReplayDeltaRequest as ::protobuf::Message>::default_instance()
    }
}

impl TMReplayDeltaRequest {
    pub fn new() -> TMReplayDeltaRequest {
        ::std::default::Default::default()
    }

    // required bytes ledgerHash = 1;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TMReplayDeltaRequest {
    fn is_initialized(&self) -> bool {
        if self.ledgerHash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMReplayDeltaRequest {
        TMReplayDeltaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMReplayDeltaRequest| { &m.ledgerHash },
                |m: &mut TMReplayDeltaRequest| { &mut m.ledgerHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMReplayDeltaRequest>(
                "TMReplayDeltaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMReplayDeltaRequest {
        static instance: ::protobuf::rt::LazyV2<TMReplayDeltaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMReplayDeltaRequest::new)
    }
}

impl ::protobuf::Clear for TMReplayDeltaRequest {
    fn clear(&mut self) {
        self.ledgerHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMReplayDeltaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMReplayDeltaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMReplayDeltaResponse {
    // message fields
    ledgerHash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerHeader: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub transaction: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    error: ::std::option::Option<TMReplyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TMReplayDeltaResponse {
    fn default() -> &'a TMReplayDeltaResponse {
        <TMReplayDeltaResponse as ::protobuf::Message>::default_instance()
    }
}

impl TMReplayDeltaResponse {
    pub fn new() -> TMReplayDeltaResponse {
        ::std::default::Default::default()
    }

    // required bytes ledgerHash = 1;


    pub fn get_ledgerHash(&self) -> &[u8] {
        match self.ledgerHash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHash(&mut self) {
        self.ledgerHash.clear();
    }

    pub fn has_ledgerHash(&self) -> bool {
        self.ledgerHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHash.is_none() {
            self.ledgerHash.set_default();
        }
        self.ledgerHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHash(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ledgerHeader = 2;


    pub fn get_ledgerHeader(&self) -> &[u8] {
        match self.ledgerHeader.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ledgerHeader(&mut self) {
        self.ledgerHeader.clear();
    }

    pub fn has_ledgerHeader(&self) -> bool {
        self.ledgerHeader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerHeader(&mut self, v: ::std::vec::Vec<u8>) {
        self.ledgerHeader = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledgerHeader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ledgerHeader.is_none() {
            self.ledgerHeader.set_default();
        }
        self.ledgerHeader.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledgerHeader(&mut self) -> ::std::vec::Vec<u8> {
        self.ledgerHeader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes transaction = 3;


    pub fn get_transaction(&self) -> &[::std::vec::Vec<u8>] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.transaction, ::protobuf::RepeatedField::new())
    }

    // optional .protocol.TMReplyError error = 4;


    pub fn get_error(&self) -> TMReplyError {
        self.error.unwrap_or(TMReplyError::reNO_LEDGER)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: TMReplyError) {
        self.error = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TMReplayDeltaResponse {
    fn is_initialized(&self) -> bool {
        if self.ledgerHash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ledgerHeader)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ledgerHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.ledgerHeader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.transaction {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ledgerHash.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.ledgerHeader.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.transaction {
            os.write_bytes(3, &v)?;
        };
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMReplayDeltaResponse {
        TMReplayDeltaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHash",
                |m: &TMReplayDeltaResponse| { &m.ledgerHash },
                |m: &mut TMReplayDeltaResponse| { &mut m.ledgerHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ledgerHeader",
                |m: &TMReplayDeltaResponse| { &m.ledgerHeader },
                |m: &mut TMReplayDeltaResponse| { &mut m.ledgerHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transaction",
                |m: &TMReplayDeltaResponse| { &m.transaction },
                |m: &mut TMReplayDeltaResponse| { &mut m.transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TMReplyError>>(
                "error",
                |m: &TMReplayDeltaResponse| { &m.error },
                |m: &mut TMReplayDeltaResponse| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TMReplayDeltaResponse>(
                "TMReplayDeltaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TMReplayDeltaResponse {
        static instance: ::protobuf::rt::LazyV2<TMReplayDeltaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TMReplayDeltaResponse::new)
    }
}

impl ::protobuf::Clear for TMReplayDeltaResponse {
    fn clear(&mut self) {
        self.ledgerHash.clear();
        self.ledgerHeader.clear();
        self.transaction.clear();
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMReplayDeltaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMReplayDeltaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageType {
    mtMANIFESTS = 2,
    mtPING = 3,
    mtCLUSTER = 5,
    mtENDPOINTS = 15,
    mtTRANSACTION = 30,
    mtGET_LEDGER = 31,
    mtLEDGER_DATA = 32,
    mtPROPOSE_LEDGER = 33,
    mtSTATUS_CHANGE = 34,
    mtHAVE_SET = 35,
    mtVALIDATION = 41,
    mtGET_OBJECTS = 42,
    mtGET_SHARD_INFO = 50,
    mtSHARD_INFO = 51,
    mtGET_PEER_SHARD_INFO = 52,
    mtPEER_SHARD_INFO = 53,
    mtVALIDATORLIST = 54,
    mtSQUELCH = 55,
    mtVALIDATORLISTCOLLECTION = 56,
    mtPROOF_PATH_REQ = 57,
    mtPROOF_PATH_RESPONSE = 58,
    mtREPLAY_DELTA_REQ = 59,
    mtREPLAY_DELTA_RESPONSE = 60,
}

impl ::protobuf::ProtobufEnum for MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            2 => ::std::option::Option::Some(MessageType::mtMANIFESTS),
            3 => ::std::option::Option::Some(MessageType::mtPING),
            5 => ::std::option::Option::Some(MessageType::mtCLUSTER),
            15 => ::std::option::Option::Some(MessageType::mtENDPOINTS),
            30 => ::std::option::Option::Some(MessageType::mtTRANSACTION),
            31 => ::std::option::Option::Some(MessageType::mtGET_LEDGER),
            32 => ::std::option::Option::Some(MessageType::mtLEDGER_DATA),
            33 => ::std::option::Option::Some(MessageType::mtPROPOSE_LEDGER),
            34 => ::std::option::Option::Some(MessageType::mtSTATUS_CHANGE),
            35 => ::std::option::Option::Some(MessageType::mtHAVE_SET),
            41 => ::std::option::Option::Some(MessageType::mtVALIDATION),
            42 => ::std::option::Option::Some(MessageType::mtGET_OBJECTS),
            50 => ::std::option::Option::Some(MessageType::mtGET_SHARD_INFO),
            51 => ::std::option::Option::Some(MessageType::mtSHARD_INFO),
            52 => ::std::option::Option::Some(MessageType::mtGET_PEER_SHARD_INFO),
            53 => ::std::option::Option::Some(MessageType::mtPEER_SHARD_INFO),
            54 => ::std::option::Option::Some(MessageType::mtVALIDATORLIST),
            55 => ::std::option::Option::Some(MessageType::mtSQUELCH),
            56 => ::std::option::Option::Some(MessageType::mtVALIDATORLISTCOLLECTION),
            57 => ::std::option::Option::Some(MessageType::mtPROOF_PATH_REQ),
            58 => ::std::option::Option::Some(MessageType::mtPROOF_PATH_RESPONSE),
            59 => ::std::option::Option::Some(MessageType::mtREPLAY_DELTA_REQ),
            60 => ::std::option::Option::Some(MessageType::mtREPLAY_DELTA_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageType] = &[
            MessageType::mtMANIFESTS,
            MessageType::mtPING,
            MessageType::mtCLUSTER,
            MessageType::mtENDPOINTS,
            MessageType::mtTRANSACTION,
            MessageType::mtGET_LEDGER,
            MessageType::mtLEDGER_DATA,
            MessageType::mtPROPOSE_LEDGER,
            MessageType::mtSTATUS_CHANGE,
            MessageType::mtHAVE_SET,
            MessageType::mtVALIDATION,
            MessageType::mtGET_OBJECTS,
            MessageType::mtGET_SHARD_INFO,
            MessageType::mtSHARD_INFO,
            MessageType::mtGET_PEER_SHARD_INFO,
            MessageType::mtPEER_SHARD_INFO,
            MessageType::mtVALIDATORLIST,
            MessageType::mtSQUELCH,
            MessageType::mtVALIDATORLISTCOLLECTION,
            MessageType::mtPROOF_PATH_REQ,
            MessageType::mtPROOF_PATH_RESPONSE,
            MessageType::mtREPLAY_DELTA_REQ,
            MessageType::mtREPLAY_DELTA_RESPONSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MessageType>("MessageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MessageType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::mtMANIFESTS
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransactionStatus {
    tsNEW = 1,
    tsCURRENT = 2,
    tsCOMMITED = 3,
    tsREJECT_CONFLICT = 4,
    tsREJECT_INVALID = 5,
    tsREJECT_FUNDS = 6,
    tsHELD_SEQ = 7,
    tsHELD_LEDGER = 8,
}

impl ::protobuf::ProtobufEnum for TransactionStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionStatus> {
        match value {
            1 => ::std::option::Option::Some(TransactionStatus::tsNEW),
            2 => ::std::option::Option::Some(TransactionStatus::tsCURRENT),
            3 => ::std::option::Option::Some(TransactionStatus::tsCOMMITED),
            4 => ::std::option::Option::Some(TransactionStatus::tsREJECT_CONFLICT),
            5 => ::std::option::Option::Some(TransactionStatus::tsREJECT_INVALID),
            6 => ::std::option::Option::Some(TransactionStatus::tsREJECT_FUNDS),
            7 => ::std::option::Option::Some(TransactionStatus::tsHELD_SEQ),
            8 => ::std::option::Option::Some(TransactionStatus::tsHELD_LEDGER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionStatus] = &[
            TransactionStatus::tsNEW,
            TransactionStatus::tsCURRENT,
            TransactionStatus::tsCOMMITED,
            TransactionStatus::tsREJECT_CONFLICT,
            TransactionStatus::tsREJECT_INVALID,
            TransactionStatus::tsREJECT_FUNDS,
            TransactionStatus::tsHELD_SEQ,
            TransactionStatus::tsHELD_LEDGER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransactionStatus>("TransactionStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransactionStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TransactionStatus {
    fn default() -> Self {
        TransactionStatus::tsNEW
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NodeStatus {
    nsCONNECTING = 1,
    nsCONNECTED = 2,
    nsMONITORING = 3,
    nsVALIDATING = 4,
    nsSHUTTING = 5,
}

impl ::protobuf::ProtobufEnum for NodeStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeStatus> {
        match value {
            1 => ::std::option::Option::Some(NodeStatus::nsCONNECTING),
            2 => ::std::option::Option::Some(NodeStatus::nsCONNECTED),
            3 => ::std::option::Option::Some(NodeStatus::nsMONITORING),
            4 => ::std::option::Option::Some(NodeStatus::nsVALIDATING),
            5 => ::std::option::Option::Some(NodeStatus::nsSHUTTING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodeStatus] = &[
            NodeStatus::nsCONNECTING,
            NodeStatus::nsCONNECTED,
            NodeStatus::nsMONITORING,
            NodeStatus::nsVALIDATING,
            NodeStatus::nsSHUTTING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodeStatus>("NodeStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodeStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NodeStatus {
    fn default() -> Self {
        NodeStatus::nsCONNECTING
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NodeEvent {
    neCLOSING_LEDGER = 1,
    neACCEPTED_LEDGER = 2,
    neSWITCHED_LEDGER = 3,
    neLOST_SYNC = 4,
}

impl ::protobuf::ProtobufEnum for NodeEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeEvent> {
        match value {
            1 => ::std::option::Option::Some(NodeEvent::neCLOSING_LEDGER),
            2 => ::std::option::Option::Some(NodeEvent::neACCEPTED_LEDGER),
            3 => ::std::option::Option::Some(NodeEvent::neSWITCHED_LEDGER),
            4 => ::std::option::Option::Some(NodeEvent::neLOST_SYNC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodeEvent] = &[
            NodeEvent::neCLOSING_LEDGER,
            NodeEvent::neACCEPTED_LEDGER,
            NodeEvent::neSWITCHED_LEDGER,
            NodeEvent::neLOST_SYNC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodeEvent>("NodeEvent", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodeEvent {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NodeEvent {
    fn default() -> Self {
        NodeEvent::neCLOSING_LEDGER
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TxSetStatus {
    tsHAVE = 1,
    tsCAN_GET = 2,
    tsNEED = 3,
}

impl ::protobuf::ProtobufEnum for TxSetStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TxSetStatus> {
        match value {
            1 => ::std::option::Option::Some(TxSetStatus::tsHAVE),
            2 => ::std::option::Option::Some(TxSetStatus::tsCAN_GET),
            3 => ::std::option::Option::Some(TxSetStatus::tsNEED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TxSetStatus] = &[
            TxSetStatus::tsHAVE,
            TxSetStatus::tsCAN_GET,
            TxSetStatus::tsNEED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TxSetStatus>("TxSetStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TxSetStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TxSetStatus {
    fn default() -> Self {
        TxSetStatus::tsHAVE
    }
}

impl ::protobuf::reflect::ProtobufValue for TxSetStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMLedgerInfoType {
    liBASE = 0,
    liTX_NODE = 1,
    liAS_NODE = 2,
    liTS_CANDIDATE = 3,
}

impl ::protobuf::ProtobufEnum for TMLedgerInfoType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMLedgerInfoType> {
        match value {
            0 => ::std::option::Option::Some(TMLedgerInfoType::liBASE),
            1 => ::std::option::Option::Some(TMLedgerInfoType::liTX_NODE),
            2 => ::std::option::Option::Some(TMLedgerInfoType::liAS_NODE),
            3 => ::std::option::Option::Some(TMLedgerInfoType::liTS_CANDIDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMLedgerInfoType] = &[
            TMLedgerInfoType::liBASE,
            TMLedgerInfoType::liTX_NODE,
            TMLedgerInfoType::liAS_NODE,
            TMLedgerInfoType::liTS_CANDIDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMLedgerInfoType>("TMLedgerInfoType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMLedgerInfoType {
}

impl ::std::default::Default for TMLedgerInfoType {
    fn default() -> Self {
        TMLedgerInfoType::liBASE
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLedgerInfoType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMLedgerType {
    ltACCEPTED = 0,
    ltCURRENT = 1,
    ltCLOSED = 2,
}

impl ::protobuf::ProtobufEnum for TMLedgerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMLedgerType> {
        match value {
            0 => ::std::option::Option::Some(TMLedgerType::ltACCEPTED),
            1 => ::std::option::Option::Some(TMLedgerType::ltCURRENT),
            2 => ::std::option::Option::Some(TMLedgerType::ltCLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMLedgerType] = &[
            TMLedgerType::ltACCEPTED,
            TMLedgerType::ltCURRENT,
            TMLedgerType::ltCLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMLedgerType>("TMLedgerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMLedgerType {
}

impl ::std::default::Default for TMLedgerType {
    fn default() -> Self {
        TMLedgerType::ltACCEPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLedgerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMQueryType {
    qtINDIRECT = 0,
}

impl ::protobuf::ProtobufEnum for TMQueryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMQueryType> {
        match value {
            0 => ::std::option::Option::Some(TMQueryType::qtINDIRECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMQueryType] = &[
            TMQueryType::qtINDIRECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMQueryType>("TMQueryType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMQueryType {
}

impl ::std::default::Default for TMQueryType {
    fn default() -> Self {
        TMQueryType::qtINDIRECT
    }
}

impl ::protobuf::reflect::ProtobufValue for TMQueryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMReplyError {
    reNO_LEDGER = 1,
    reNO_NODE = 2,
    reBAD_REQUEST = 3,
}

impl ::protobuf::ProtobufEnum for TMReplyError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMReplyError> {
        match value {
            1 => ::std::option::Option::Some(TMReplyError::reNO_LEDGER),
            2 => ::std::option::Option::Some(TMReplyError::reNO_NODE),
            3 => ::std::option::Option::Some(TMReplyError::reBAD_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMReplyError] = &[
            TMReplyError::reNO_LEDGER,
            TMReplyError::reNO_NODE,
            TMReplyError::reBAD_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMReplyError>("TMReplyError", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMReplyError {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TMReplyError {
    fn default() -> Self {
        TMReplyError::reNO_LEDGER
    }
}

impl ::protobuf::reflect::ProtobufValue for TMReplyError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TMLedgerMapType {
    lmTRANASCTION = 1,
    lmACCOUNT_STATE = 2,
}

impl ::protobuf::ProtobufEnum for TMLedgerMapType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TMLedgerMapType> {
        match value {
            1 => ::std::option::Option::Some(TMLedgerMapType::lmTRANASCTION),
            2 => ::std::option::Option::Some(TMLedgerMapType::lmACCOUNT_STATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TMLedgerMapType] = &[
            TMLedgerMapType::lmTRANASCTION,
            TMLedgerMapType::lmACCOUNT_STATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TMLedgerMapType>("TMLedgerMapType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TMLedgerMapType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TMLedgerMapType {
    fn default() -> Self {
        TMLedgerMapType::lmTRANASCTION
    }
}

impl ::protobuf::reflect::ProtobufValue for TMLedgerMapType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cripple.proto\x12\x08protocol\",\n\nTMManifest\x12\x1c\n\x08stobjec\
    t\x18\x01\x20\x02(\x0cR\x08stobjectB\0:\0\"Y\n\x0bTMManifests\x12*\n\x04\
    list\x18\x01\x20\x03(\x0b2\x14.protocol.TMManifestR\x04listB\0\x12\x1c\n\
    \x07history\x18\x02\x20\x01(\x08R\x07historyB\x02\x18\x01:\0\"\xab\x01\n\
    \rTMClusterNode\x12\x1e\n\tpublicKey\x18\x01\x20\x02(\tR\tpublicKeyB\0\
    \x12\x20\n\nreportTime\x18\x02\x20\x02(\rR\nreportTimeB\0\x12\x1c\n\x08n\
    odeLoad\x18\x03\x20\x02(\rR\x08nodeLoadB\0\x12\x1c\n\x08nodeName\x18\x04\
    \x20\x01(\tR\x08nodeNameB\0\x12\x1a\n\x07address\x18\x05\x20\x01(\tR\x07\
    addressB\0:\0\"T\n\x0cTMLoadSource\x12\x14\n\x04name\x18\x01\x20\x02(\tR\
    \x04nameB\0\x12\x14\n\x04cost\x18\x02\x20\x02(\rR\x04costB\0\x12\x16\n\
    \x05count\x18\x03\x20\x01(\rR\x05countB\0:\0\"\x88\x01\n\tTMCluster\x12=\
    \n\x0cclusterNodes\x18\x01\x20\x03(\x0b2\x17.protocol.TMClusterNodeR\x0c\
    clusterNodesB\0\x12:\n\x0bloadSources\x18\x02\x20\x03(\x0b2\x16.protocol\
    .TMLoadSourceR\x0bloadSourcesB\0:\0\"l\n\x0eTMGetShardInfo\x12\x16\n\x04\
    hops\x18\x01\x20\x02(\rR\x04hopsB\x02\x18\x01\x12\x1e\n\x08lastLink\x18\
    \x02\x20\x01(\x08R\x08lastLinkB\x02\x18\x01\x12\x20\n\tpeerchain\x18\x03\
    \x20\x03(\rR\tpeerchainB\x02\x18\x01:\0\"\xbd\x01\n\x0bTMShardInfo\x12&\
    \n\x0cshardIndexes\x18\x01\x20\x02(\tR\x0cshardIndexesB\x02\x18\x01\x12\
    \"\n\nnodePubKey\x18\x02\x20\x01(\x0cR\nnodePubKeyB\x02\x18\x01\x12\x1e\
    \n\x08endpoint\x18\x03\x20\x01(\tR\x08endpointB\x02\x18\x01\x12\x1e\n\
    \x08lastLink\x18\x04\x20\x01(\x08R\x08lastLinkB\x02\x18\x01\x12\x20\n\tp\
    eerchain\x18\x05\x20\x03(\rR\tpeerchainB\x02\x18\x01:\0\",\n\x06TMLink\
    \x12\x20\n\nnodePubKey\x18\x01\x20\x02(\x0cR\nnodePubKeyB\0:\0\"|\n\x12T\
    MGetPeerShardInfo\x12\x14\n\x04hops\x18\x01\x20\x02(\rR\x04hopsB\0\x12\
    \x1c\n\x08lastLink\x18\x02\x20\x01(\x08R\x08lastLinkB\0\x120\n\tpeerChai\
    n\x18\x03\x20\x03(\x0b2\x10.protocol.TMLinkR\tpeerChainB\0:\0\"\xc9\x01\
    \n\x0fTMPeerShardInfo\x12$\n\x0cshardIndexes\x18\x01\x20\x02(\tR\x0cshar\
    dIndexesB\0\x12\x20\n\nnodePubKey\x18\x02\x20\x01(\x0cR\nnodePubKeyB\0\
    \x12\x1c\n\x08endpoint\x18\x03\x20\x01(\tR\x08endpointB\0\x12\x1c\n\x08l\
    astLink\x18\x04\x20\x01(\x08R\x08lastLinkB\0\x120\n\tpeerChain\x18\x05\
    \x20\x03(\x0b2\x10.protocol.TMLinkR\tpeerChainB\0:\0\"\xbe\x01\n\rTMTran\
    saction\x12(\n\x0erawTransaction\x18\x01\x20\x02(\x0cR\x0erawTransaction\
    B\0\x125\n\x06status\x18\x02\x20\x02(\x0e2\x1b.protocol.TransactionStatu\
    sR\x06statusB\0\x12,\n\x10receiveTimestamp\x18\x03\x20\x01(\x04R\x10rece\
    iveTimestampB\0\x12\x1c\n\x08deferred\x18\x04\x20\x01(\x08R\x08deferredB\
    \0:\0\"\xcd\x02\n\x0eTMStatusChange\x124\n\tnewStatus\x18\x01\x20\x01(\
    \x0e2\x14.protocol.NodeStatusR\tnewStatusB\0\x121\n\x08newEvent\x18\x02\
    \x20\x01(\x0e2\x13.protocol.NodeEventR\x08newEventB\0\x12\x1e\n\tledgerS\
    eq\x18\x03\x20\x01(\rR\tledgerSeqB\0\x12\x20\n\nledgerHash\x18\x04\x20\
    \x01(\x0cR\nledgerHashB\0\x120\n\x12ledgerHashPrevious\x18\x05\x20\x01(\
    \x0cR\x12ledgerHashPreviousB\0\x12\"\n\x0bnetworkTime\x18\x06\x20\x01(\
    \x04R\x0bnetworkTimeB\0\x12\x1c\n\x08firstSeq\x18\x07\x20\x01(\rR\x08fir\
    stSeqB\0\x12\x1a\n\x07lastSeq\x18\x08\x20\x01(\rR\x07lastSeqB\0:\0\"\x92\
    \x03\n\x0cTMProposeSet\x12\x20\n\nproposeSeq\x18\x01\x20\x02(\rR\npropos\
    eSeqB\0\x12&\n\rcurrentTxHash\x18\x02\x20\x02(\x0cR\rcurrentTxHashB\0\
    \x12\x20\n\nnodePubKey\x18\x03\x20\x02(\x0cR\nnodePubKeyB\0\x12\x1e\n\tc\
    loseTime\x18\x04\x20\x02(\rR\tcloseTimeB\0\x12\x1e\n\tsignature\x18\x05\
    \x20\x02(\x0cR\tsignatureB\0\x12(\n\x0epreviousledger\x18\x06\x20\x02(\
    \x0cR\x0epreviousledgerB\0\x12.\n\x11addedTransactions\x18\n\x20\x03(\
    \x0cR\x11addedTransactionsB\0\x122\n\x13removedTransactions\x18\x0b\x20\
    \x03(\x0cR\x13removedTransactionsB\0\x12.\n\x10checkedSignature\x18\x07\
    \x20\x01(\x08R\x10checkedSignatureB\x02\x18\x01\x12\x16\n\x04hops\x18\
    \x0c\x20\x01(\rR\x04hopsB\x02\x18\x01:\0\"_\n\x14TMHaveTransactionSet\
    \x12/\n\x06status\x18\x01\x20\x02(\x0e2\x15.protocol.TxSetStatusR\x06sta\
    tusB\0\x12\x14\n\x04hash\x18\x02\x20\x02(\x0cR\x04hashB\0:\0\"\x83\x01\n\
    \x0fTMValidatorList\x12\x1c\n\x08manifest\x18\x01\x20\x02(\x0cR\x08manif\
    estB\0\x12\x14\n\x04blob\x18\x02\x20\x02(\x0cR\x04blobB\0\x12\x1e\n\tsig\
    nature\x18\x03\x20\x02(\x0cR\tsignatureB\0\x12\x1a\n\x07version\x18\x04\
    \x20\x02(\rR\x07versionB\0:\0\"i\n\x11ValidatorBlobInfo\x12\x1c\n\x08man\
    ifest\x18\x01\x20\x01(\x0cR\x08manifestB\0\x12\x14\n\x04blob\x18\x02\x20\
    \x02(\x0cR\x04blobB\0\x12\x1e\n\tsignature\x18\x03\x20\x02(\x0cR\tsignat\
    ureB\0:\0\"\x8c\x01\n\x19TMValidatorListCollection\x12\x1a\n\x07version\
    \x18\x01\x20\x02(\rR\x07versionB\0\x12\x1c\n\x08manifest\x18\x02\x20\x02\
    (\x0cR\x08manifestB\0\x123\n\x05blobs\x18\x03\x20\x03(\x0b2\x1b.protocol\
    .ValidatorBlobInfoR\x05blobsB\0:\0\"z\n\x0cTMValidation\x12\x20\n\nvalid\
    ation\x18\x01\x20\x02(\x0cR\nvalidationB\0\x12.\n\x10checkedSignature\
    \x18\x02\x20\x01(\x08R\x10checkedSignatureB\x02\x18\x01\x12\x16\n\x04hop\
    s\x18\x03\x20\x01(\rR\x04hopsB\x02\x18\x01:\0\"\xba\x01\n\x0bTMEndpoints\
    \x12\x1a\n\x07version\x18\x01\x20\x02(\rR\x07versionB\0\x12G\n\x0cendpoi\
    nts_v2\x18\x03\x20\x03(\x0b2\".protocol.TMEndpoints.TMEndpointv2R\x0bend\
    pointsV2B\0\x1aD\n\x0cTMEndpointv2\x12\x1c\n\x08endpoint\x18\x01\x20\x02\
    (\tR\x08endpointB\0\x12\x14\n\x04hops\x18\x02\x20\x02(\rR\x04hopsB\0:\0:\
    \0\"\x91\x01\n\x0fTMIndexedObject\x12\x14\n\x04hash\x18\x01\x20\x01(\x0c\
    R\x04hashB\0\x12\x18\n\x06nodeID\x18\x02\x20\x01(\x0cR\x06nodeIDB\0\x12\
    \x16\n\x05index\x18\x03\x20\x01(\x0cR\x05indexB\0\x12\x14\n\x04data\x18\
    \x04\x20\x01(\x0cR\x04dataB\0\x12\x1e\n\tledgerSeq\x18\x05\x20\x01(\rR\t\
    ledgerSeqB\0:\0\"\xfb\x02\n\x11TMGetObjectByHash\x12<\n\x04type\x18\x01\
    \x20\x02(\x0e2&.protocol.TMGetObjectByHash.ObjectTypeR\x04typeB\0\x12\
    \x16\n\x05query\x18\x02\x20\x02(\x08R\x05queryB\0\x12\x12\n\x03seq\x18\
    \x03\x20\x01(\rR\x03seqB\0\x12\x20\n\nledgerHash\x18\x04\x20\x01(\x0cR\n\
    ledgerHashB\0\x12\x12\n\x03fat\x18\x05\x20\x01(\x08R\x03fatB\0\x125\n\
    \x07objects\x18\x06\x20\x03(\x0b2\x19.protocol.TMIndexedObjectR\x07objec\
    tsB\0\"\x8c\x01\n\nObjectType\x12\r\n\totUNKNOWN\x10\0\x12\x0c\n\x08otLE\
    DGER\x10\x01\x12\x11\n\rotTRANSACTION\x10\x02\x12\x16\n\x12otTRANSACTION\
    _NODE\x10\x03\x12\x10\n\x0cotSTATE_NODE\x10\x04\x12\x10\n\x0cotCAS_OBJEC\
    T\x10\x05\x12\x10\n\x0cotFETCH_PACK\x10\x06\x1a\0:\0\"H\n\x0cTMLedgerNod\
    e\x12\x1c\n\x08nodedata\x18\x01\x20\x02(\x0cR\x08nodedataB\0\x12\x18\n\
    \x06nodeid\x18\x02\x20\x01(\x0cR\x06nodeidB\0:\0\"\xd2\x02\n\x0bTMGetLed\
    ger\x122\n\x05itype\x18\x01\x20\x02(\x0e2\x1a.protocol.TMLedgerInfoTypeR\
    \x05itypeB\0\x12.\n\x05ltype\x18\x02\x20\x01(\x0e2\x16.protocol.TMLedger\
    TypeR\x05ltypeB\0\x12\x20\n\nledgerHash\x18\x03\x20\x01(\x0cR\nledgerHas\
    hB\0\x12\x1e\n\tledgerSeq\x18\x04\x20\x01(\rR\tledgerSeqB\0\x12\x1a\n\
    \x07nodeIDs\x18\x05\x20\x03(\x0cR\x07nodeIDsB\0\x12&\n\rrequestCookie\
    \x18\x06\x20\x01(\x04R\rrequestCookieB\0\x125\n\tqueryType\x18\x07\x20\
    \x01(\x0e2\x15.protocol.TMQueryTypeR\tqueryTypeB\0\x12\x20\n\nqueryDepth\
    \x18\x08\x20\x01(\rR\nqueryDepthB\0:\0\"\x8c\x02\n\x0cTMLedgerData\x12\
    \x20\n\nledgerHash\x18\x01\x20\x02(\x0cR\nledgerHashB\0\x12\x1e\n\tledge\
    rSeq\x18\x02\x20\x02(\rR\tledgerSeqB\0\x120\n\x04type\x18\x03\x20\x02(\
    \x0e2\x1a.protocol.TMLedgerInfoTypeR\x04typeB\0\x12.\n\x05nodes\x18\x04\
    \x20\x03(\x0b2\x16.protocol.TMLedgerNodeR\x05nodesB\0\x12&\n\rrequestCoo\
    kie\x18\x05\x20\x01(\rR\rrequestCookieB\0\x12.\n\x05error\x18\x06\x20\
    \x01(\x0e2\x16.protocol.TMReplyErrorR\x05errorB\0:\0\"\xaf\x01\n\x06TMPi\
    ng\x12/\n\x04type\x18\x01\x20\x02(\x0e2\x19.protocol.TMPing.pingTypeR\
    \x04typeB\0\x12\x12\n\x03seq\x18\x02\x20\x01(\rR\x03seqB\0\x12\x1c\n\x08\
    pingTime\x18\x03\x20\x01(\x04R\x08pingTimeB\0\x12\x1a\n\x07netTime\x18\
    \x04\x20\x01(\x04R\x07netTimeB\0\"$\n\x08pingType\x12\n\n\x06ptPING\x10\
    \0\x12\n\n\x06ptPONG\x10\x01\x1a\0:\0\"\x81\x01\n\tTMSquelch\x12\x1a\n\
    \x07squelch\x18\x01\x20\x02(\x08R\x07squelchB\0\x12*\n\x0fvalidatorPubKe\
    y\x18\x02\x20\x02(\x0cR\x0fvalidatorPubKeyB\0\x12*\n\x0fsquelchDuration\
    \x18\x03\x20\x01(\rR\x0fsquelchDurationB\0:\0\"}\n\x12TMProofPathRequest\
    \x12\x12\n\x03key\x18\x01\x20\x02(\x0cR\x03keyB\0\x12\x20\n\nledgerHash\
    \x18\x02\x20\x02(\x0cR\nledgerHashB\0\x12/\n\x04type\x18\x03\x20\x02(\
    \x0e2\x19.protocol.TMLedgerMapTypeR\x04typeB\0:\0\"\xea\x01\n\x13TMProof\
    PathResponse\x12\x12\n\x03key\x18\x01\x20\x02(\x0cR\x03keyB\0\x12\x20\n\
    \nledgerHash\x18\x02\x20\x02(\x0cR\nledgerHashB\0\x12/\n\x04type\x18\x03\
    \x20\x02(\x0e2\x19.protocol.TMLedgerMapTypeR\x04typeB\0\x12$\n\x0cledger\
    Header\x18\x04\x20\x01(\x0cR\x0cledgerHeaderB\0\x12\x14\n\x04path\x18\
    \x05\x20\x03(\x0cR\x04pathB\0\x12.\n\x05error\x18\x06\x20\x01(\x0e2\x16.\
    protocol.TMReplyErrorR\x05errorB\0:\0\":\n\x14TMReplayDeltaRequest\x12\
    \x20\n\nledgerHash\x18\x01\x20\x02(\x0cR\nledgerHashB\0:\0\"\xb5\x01\n\
    \x15TMReplayDeltaResponse\x12\x20\n\nledgerHash\x18\x01\x20\x02(\x0cR\nl\
    edgerHashB\0\x12$\n\x0cledgerHeader\x18\x02\x20\x01(\x0cR\x0cledgerHeade\
    rB\0\x12\"\n\x0btransaction\x18\x03\x20\x03(\x0cR\x0btransactionB\0\x12.\
    \n\x05error\x18\x04\x20\x01(\x0e2\x16.protocol.TMReplyErrorR\x05errorB\0\
    :\0*\xe7\x03\n\x0bMessageType\x12\x0f\n\x0bmtMANIFESTS\x10\x02\x12\n\n\
    \x06mtPING\x10\x03\x12\r\n\tmtCLUSTER\x10\x05\x12\x0f\n\x0bmtENDPOINTS\
    \x10\x0f\x12\x11\n\rmtTRANSACTION\x10\x1e\x12\x10\n\x0cmtGET_LEDGER\x10\
    \x1f\x12\x11\n\rmtLEDGER_DATA\x10\x20\x12\x14\n\x10mtPROPOSE_LEDGER\x10!\
    \x12\x13\n\x0fmtSTATUS_CHANGE\x10\"\x12\x0e\n\nmtHAVE_SET\x10#\x12\x10\n\
    \x0cmtVALIDATION\x10)\x12\x11\n\rmtGET_OBJECTS\x10*\x12\x14\n\x10mtGET_S\
    HARD_INFO\x102\x12\x10\n\x0cmtSHARD_INFO\x103\x12\x19\n\x15mtGET_PEER_SH\
    ARD_INFO\x104\x12\x15\n\x11mtPEER_SHARD_INFO\x105\x12\x13\n\x0fmtVALIDAT\
    ORLIST\x106\x12\r\n\tmtSQUELCH\x107\x12\x1d\n\x19mtVALIDATORLISTCOLLECTI\
    ON\x108\x12\x14\n\x10mtPROOF_PATH_REQ\x109\x12\x19\n\x15mtPROOF_PATH_RES\
    PONSE\x10:\x12\x16\n\x12mtREPLAY_DELTA_REQ\x10;\x12\x1b\n\x17mtREPLAY_DE\
    LTA_RESPONSE\x10<\x1a\0*\xa3\x01\n\x11TransactionStatus\x12\t\n\x05tsNEW\
    \x10\x01\x12\r\n\ttsCURRENT\x10\x02\x12\x0e\n\ntsCOMMITED\x10\x03\x12\
    \x15\n\x11tsREJECT_CONFLICT\x10\x04\x12\x14\n\x10tsREJECT_INVALID\x10\
    \x05\x12\x12\n\x0etsREJECT_FUNDS\x10\x06\x12\x0e\n\ntsHELD_SEQ\x10\x07\
    \x12\x11\n\rtsHELD_LEDGER\x10\x08\x1a\0*e\n\nNodeStatus\x12\x10\n\x0cnsC\
    ONNECTING\x10\x01\x12\x0f\n\x0bnsCONNECTED\x10\x02\x12\x10\n\x0cnsMONITO\
    RING\x10\x03\x12\x10\n\x0cnsVALIDATING\x10\x04\x12\x0e\n\nnsSHUTTING\x10\
    \x05\x1a\0*b\n\tNodeEvent\x12\x14\n\x10neCLOSING_LEDGER\x10\x01\x12\x15\
    \n\x11neACCEPTED_LEDGER\x10\x02\x12\x15\n\x11neSWITCHED_LEDGER\x10\x03\
    \x12\x0f\n\x0bneLOST_SYNC\x10\x04\x1a\0*6\n\x0bTxSetStatus\x12\n\n\x06ts\
    HAVE\x10\x01\x12\r\n\ttsCAN_GET\x10\x02\x12\n\n\x06tsNEED\x10\x03\x1a\0*\
    R\n\x10TMLedgerInfoType\x12\n\n\x06liBASE\x10\0\x12\r\n\tliTX_NODE\x10\
    \x01\x12\r\n\tliAS_NODE\x10\x02\x12\x12\n\x0eliTS_CANDIDATE\x10\x03\x1a\
    \0*=\n\x0cTMLedgerType\x12\x0e\n\nltACCEPTED\x10\0\x12\r\n\tltCURRENT\
    \x10\x01\x12\x0c\n\x08ltCLOSED\x10\x02\x1a\0*\x1f\n\x0bTMQueryType\x12\
    \x0e\n\nqtINDIRECT\x10\0\x1a\0*C\n\x0cTMReplyError\x12\x0f\n\x0breNO_LED\
    GER\x10\x01\x12\r\n\treNO_NODE\x10\x02\x12\x11\n\rreBAD_REQUEST\x10\x03\
    \x1a\0*;\n\x0fTMLedgerMapType\x12\x11\n\rlmTRANASCTION\x10\x01\x12\x13\n\
    \x0flmACCOUNT_STATE\x10\x02\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
